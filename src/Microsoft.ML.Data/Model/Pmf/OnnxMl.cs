// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: onnx-ml.proto3
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace ONNX {

  /// <summary>Holder for reflection information generated from onnx-ml.proto3</summary>
  public static partial class OnnxMlReflection {

    #region Descriptor
    /// <summary>File descriptor for onnx-ml.proto3</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OnnxMlReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg5vbm54LW1sLnByb3RvMxIEb25ueCKfDQoOQXR0cmlidXRlUHJvdG8SDAoE",
            "bmFtZRgBIAEoCRIVCg1yZWZfYXR0cl9uYW1lGBUgASgJEhIKCmRvY19zdHJp",
            "bmcYDSABKAkSMAoEdHlwZRgUIAEoDjIiLm9ubnguQXR0cmlidXRlUHJvdG8u",
            "QXR0cmlidXRlVHlwZRIJCgFmGAIgASgCEgkKAWkYAyABKAMSCQoBcxgEIAEo",
            "DBIcCgF0GAUgASgLMhEub25ueC5UZW5zb3JQcm90bxIbCgFnGAYgASgLMhAu",
            "b25ueC5HcmFwaFByb3RvEg4KBmZsb2F0cxgHIAMoAhIMCgRpbnRzGAggAygD",
            "Eg8KB3N0cmluZ3MYCSADKAwSIgoHdGVuc29ycxgKIAMoCzIRLm9ubnguVGVu",
            "c29yUHJvdG8SIAoGZ3JhcGhzGAsgAygLMhAub25ueC5HcmFwaFByb3RvEjIK",
            "BXR1cGxlGGQgASgLMiMub25ueC5BdHRyaWJ1dGVQcm90by5UdXBsZUF0dHJp",
            "YnV0ZRI0CgZyZWNvcmQYZSABKAsyJC5vbm54LkF0dHJpYnV0ZVByb3RvLlJl",
            "Y29yZEF0dHJpYnV0ZRI4CghudWxsYWJsZRhmIAEoCzImLm9ubnguQXR0cmli",
            "dXRlUHJvdG8uTnVsbGFibGVBdHRyaWJ1dGUSOgoGc3BhcnNlGGcgASgLMiou",
            "b25ueC5BdHRyaWJ1dGVQcm90by5TcGFyc2VUZW5zb3JBdHRyaWJ1dGUSDQoF",
            "dHlwZWEYaCABKAkSMwoGdHVwbGVzGGkgAygLMiMub25ueC5BdHRyaWJ1dGVQ",
            "cm90by5UdXBsZUF0dHJpYnV0ZRI1CgdyZWNvcmRzGGogAygLMiQub25ueC5B",
            "dHRyaWJ1dGVQcm90by5SZWNvcmRBdHRyaWJ1dGUSOQoJbnVsbGFibGVzGGsg",
            "AygLMiYub25ueC5BdHRyaWJ1dGVQcm90by5OdWxsYWJsZUF0dHJpYnV0ZRI7",
            "CgdzcGFyc2VzGGwgAygLMioub25ueC5BdHRyaWJ1dGVQcm90by5TcGFyc2VU",
            "ZW5zb3JBdHRyaWJ1dGUSDQoFdHlwZXMYbSADKAkaNgoOVHVwbGVBdHRyaWJ1",
            "dGUSJAoGdmFsdWVzGAEgAygLMhQub25ueC5BdHRyaWJ1dGVQcm90bxpVCg9S",
            "ZWNvcmRBdHRyaWJ1dGUSDAoEbmFtZRgBIAEoCRIOCgZkb21haW4YAiABKAkS",
            "JAoGdmFsdWVzGAMgAygLMhQub25ueC5BdHRyaWJ1dGVQcm90bxo4ChFOdWxs",
            "YWJsZUF0dHJpYnV0ZRIjCgV2YWx1ZRgBIAEoCzIULm9ubnguQXR0cmlidXRl",
            "UHJvdG8algMKFVNwYXJzZVRlbnNvckF0dHJpYnV0ZRIMCgRkaW1zGAEgAygD",
            "Ei0KCWRhdGFfdHlwZRgCIAEoDjIaLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5",
            "cGUSUgoLeWFsZV9mb3JtYXQYAyABKAsyOy5vbm54LkF0dHJpYnV0ZVByb3Rv",
            "LlNwYXJzZVRlbnNvckF0dHJpYnV0ZS5ZYWxlRm9ybWF0VGVuc29ySAASSgoH",
            "b25lX2hvdBgEIAEoCzI3Lm9ubnguQXR0cmlidXRlUHJvdG8uU3BhcnNlVGVu",
            "c29yQXR0cmlidXRlLk9uZUhvdFRlbnNvckgAGm8KEFlhbGVGb3JtYXRUZW5z",
            "b3ISLAoRbm9uX3plcm9fZWxlbWVudHMYASABKAsyES5vbm54LlRlbnNvclBy",
            "b3RvEhUKDWZpcnN0X2luZGljZXMYAiADKAMSFgoOY29sdW1uX2luZGljZXMY",
            "AyADKAMaJgoMT25lSG90VGVuc29yEhYKDmxpbmVhcl9pbmRpY2VzGAEgAygD",
            "QgcKBXZhbHVlIowCCg1BdHRyaWJ1dGVUeXBlEg0KCVVOREVGSU5FRBAAEgkK",
            "BUZMT0FUEAESBwoDSU5UEAISCgoGU1RSSU5HEAMSCgoGVEVOU09SEAQSCQoF",
            "R1JBUEgQBRIKCgZGTE9BVFMQBhIICgRJTlRTEAcSCwoHU1RSSU5HUxAIEgsK",
            "B1RFTlNPUlMQCRIKCgZHUkFQSFMQChIJCgVUVVBMRRALEgoKBlJFQ09SRBAM",
            "EgwKCE5VTExBQkxFEA0SCgoGU1BBUlNFEA4SCAoEVFlQRRAPEgoKBlRVUExF",
            "UxAQEgsKB1JFQ09SRFMQERINCglOVUxMQUJMRVMQEhILCgdTUEFSU0VTEBMS",
            "CQoFVFlQRVMQFCJRCg5WYWx1ZUluZm9Qcm90bxIMCgRuYW1lGAEgASgJEh0K",
            "BHR5cGUYAiABKAsyDy5vbm54LlR5cGVQcm90bxISCgpkb2Nfc3RyaW5nGAMg",
            "ASgJIpYBCglOb2RlUHJvdG8SDQoFaW5wdXQYASADKAkSDgoGb3V0cHV0GAIg",
            "AygJEgwKBG5hbWUYAyABKAkSDwoHb3BfdHlwZRgEIAEoCRIOCgZkb21haW4Y",
            "ByABKAkSJwoJYXR0cmlidXRlGAUgAygLMhQub25ueC5BdHRyaWJ1dGVQcm90",
            "bxISCgpkb2Nfc3RyaW5nGAYgASgJIsYCCgpNb2RlbFByb3RvEhIKCmlyX3Zl",
            "cnNpb24YASABKAMSLgoMb3BzZXRfaW1wb3J0GAggAygLMhgub25ueC5PcGVy",
            "YXRvclNldElkUHJvdG8SFQoNcHJvZHVjZXJfbmFtZRgCIAEoCRIYChBwcm9k",
            "dWNlcl92ZXJzaW9uGAMgASgJEg4KBmRvbWFpbhgEIAEoCRIVCg1tb2RlbF92",
            "ZXJzaW9uGAUgASgDEhIKCmRvY19zdHJpbmcYBiABKAkSHwoFZ3JhcGgYByAB",
            "KAsyEC5vbm54LkdyYXBoUHJvdG8SNAoObWV0YWRhdGFfcHJvcHMYDiADKAsy",
            "HC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8SMQoPZXh0ZXJuYWxfbW9k",
            "ZWxzGA8gAygLMhgub25ueC5FeHRlcm5hbE1vZGVsUHJvdG8iNAoWU3RyaW5n",
            "U3RyaW5nRW50cnlQcm90bxILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAki",
            "6gEKCkdyYXBoUHJvdG8SHQoEbm9kZRgBIAMoCzIPLm9ubnguTm9kZVByb3Rv",
            "EgwKBG5hbWUYAiABKAkSJgoLaW5pdGlhbGl6ZXIYBSADKAsyES5vbm54LlRl",
            "bnNvclByb3RvEhIKCmRvY19zdHJpbmcYCiABKAkSIwoFaW5wdXQYCyADKAsy",
            "FC5vbm54LlZhbHVlSW5mb1Byb3RvEiQKBm91dHB1dBgMIAMoCzIULm9ubngu",
            "VmFsdWVJbmZvUHJvdG8SKAoKdmFsdWVfaW5mbxgNIAMoCzIULm9ubnguVmFs",
            "dWVJbmZvUHJvdG8irwQKC1RlbnNvclByb3RvEgwKBGRpbXMYASADKAMSLQoJ",
            "ZGF0YV90eXBlGAIgASgOMhoub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZRIq",
            "CgdzZWdtZW50GAMgASgLMhkub25ueC5UZW5zb3JQcm90by5TZWdtZW50EhYK",
            "CmZsb2F0X2RhdGEYBCADKAJCAhABEhYKCmludDMyX2RhdGEYBSADKAVCAhAB",
            "EhMKC3N0cmluZ19kYXRhGAYgAygMEhYKCmludDY0X2RhdGEYByADKANCAhAB",
            "EgwKBG5hbWUYCCABKAkSEgoKZG9jX3N0cmluZxgMIAEoCRIQCghyYXdfZGF0",
            "YRgJIAEoDBIXCgtkb3VibGVfZGF0YRgKIAMoAUICEAESFwoLdWludDY0X2Rh",
            "dGEYCyADKARCAhABGiUKB1NlZ21lbnQSDQoFYmVnaW4YASABKAMSCwoDZW5k",
            "GAIgASgDIswBCghEYXRhVHlwZRINCglVTkRFRklORUQQABIJCgVGTE9BVBAB",
            "EgkKBVVJTlQ4EAISCAoESU5UOBADEgoKBlVJTlQxNhAEEgkKBUlOVDE2EAUS",
            "CQoFSU5UMzIQBhIJCgVJTlQ2NBAHEgoKBlNUUklORxAIEggKBEJPT0wQCRIL",
            "CgdGTE9BVDE2EAoSCgoGRE9VQkxFEAsSCgoGVUlOVDMyEAwSCgoGVUlOVDY0",
            "EA0SDQoJQ09NUExFWDY0EA4SDgoKQ09NUExFWDEyOBAPIpUBChBUZW5zb3JT",
            "aGFwZVByb3RvEi0KA2RpbRgBIAMoCzIgLm9ubnguVGVuc29yU2hhcGVQcm90",
            "by5EaW1lbnNpb24aUgoJRGltZW5zaW9uEhMKCWRpbV92YWx1ZRgBIAEoA0gA",
            "EhMKCWRpbV9wYXJhbRgCIAEoCUgAEhIKCmRlbm90YXRpb24YAyABKAlCBwoF",
            "dmFsdWUisQgKCVR5cGVQcm90bxItCgt0ZW5zb3JfdHlwZRgBIAEoCzIWLm9u",
            "bnguVHlwZVByb3RvLlRlbnNvckgAEjEKDXNlcXVlbmNlX3R5cGUYBCABKAsy",
            "GC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZUgAEicKCG1hcF90eXBlGAUgASgL",
            "MhMub25ueC5UeXBlUHJvdG8uTWFwSAASKwoKdHVwbGVfdHlwZRgHIAEoCzIV",
            "Lm9ubnguVHlwZVByb3RvLlR1cGxlSAASLQoLb3BhcXVlX3R5cGUYCCABKAsy",
            "Fi5vbm54LlR5cGVQcm90by5PcGFxdWVIABIzCgtzcGFyc2VfdHlwZRgJIAEo",
            "CzIcLm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvckgAEi0KC3JlY29yZF90",
            "eXBlGAogASgLMhYub25ueC5UeXBlUHJvdG8uUmVjb3JkSAASMQoNbnVsbGFi",
            "bGVfdHlwZRgLIAEoCzIYLm9ubnguVHlwZVByb3RvLk51bGxhYmxlSAASLQoL",
            "c2NhbGFyX3R5cGUYDCABKAsyFi5vbm54LlR5cGVQcm90by5TY2FsYXJIABIS",
            "CgpkZW5vdGF0aW9uGAYgASgJGl4KBlRlbnNvchItCgllbGVtX3R5cGUYASAB",
            "KA4yGi5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlEiUKBXNoYXBlGAIgASgL",
            "MhYub25ueC5UZW5zb3JTaGFwZVByb3RvGjcKBlNjYWxhchItCglkYXRhX3R5",
            "cGUYASABKA4yGi5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlGi4KCFNlcXVl",
            "bmNlEiIKCWVsZW1fdHlwZRgBIAEoCzIPLm9ubnguVHlwZVByb3RvGisKBVR1",
            "cGxlEiIKCWVsZW1fdHlwZRgBIAMoCzIPLm9ubnguVHlwZVByb3RvGkwKBlJl",
            "Y29yZBIOCgZkb21haW4YASABKAkSDAoEbmFtZRgCIAEoCRIkCgZmaWVsZHMY",
            "AyADKAsyFC5vbm54LlZhbHVlSW5mb1Byb3RvGiYKBk9wYXF1ZRIOCgZkb21h",
            "aW4YASABKAkSDAoEbmFtZRgCIAEoCRpkCgxTcGFyc2VUZW5zb3ISLQoJZWxl",
            "bV90eXBlGAEgASgOMhoub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZRIlCgVz",
            "aGFwZRgCIAEoCzIWLm9ubnguVGVuc29yU2hhcGVQcm90bxouCghOdWxsYWJs",
            "ZRIiCgliYXNlX3R5cGUYASABKAsyDy5vbm54LlR5cGVQcm90bxpYCgNNYXAS",
            "LAoIa2V5X3R5cGUYASABKA4yGi5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBl",
            "EiMKCnZhbHVlX3R5cGUYAiABKAsyDy5vbm54LlR5cGVQcm90b0IHCgV2YWx1",
            "ZSI1ChJPcGVyYXRvclNldElkUHJvdG8SDgoGZG9tYWluGAEgASgJEg8KB3Zl",
            "cnNpb24YAiABKAMiQwoSRXh0ZXJuYWxNb2RlbFByb3RvEg4KBmRvbWFpbhgB",
            "IAEoCRIMCgRuYW1lGAIgASgJEg8KB3ZlcnNpb24YAyABKAMqfgoHVmVyc2lv",
            "bhISCg5fU1RBUlRfVkVSU0lPThAAEhkKFUlSX1ZFUlNJT05fMjAxN18xMF8x",
            "MBABEhkKFUlSX1ZFUlNJT05fMjAxN18xMF8zMBACEhkKFUlSX1ZFUlNJT05f",
            "MjAxN18xMV8wMxADEg4KCklSX1ZFUlNJT04QBEIHqgIET05OWGIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::ONNX.Version), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.AttributeProto), global::ONNX.AttributeProto.Parser, new[]{ "Name", "RefAttrName", "DocString", "Type", "F", "I", "S", "T", "G", "Floats", "Ints", "Strings", "Tensors", "Graphs", "Tuple", "Record", "Nullable", "Sparse", "Typea", "Tuples", "Records", "Nullables", "Sparses", "Types_" }, null, new[]{ typeof(global::ONNX.AttributeProto.Types.AttributeType) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.AttributeProto.Types.TupleAttribute), global::ONNX.AttributeProto.Types.TupleAttribute.Parser, new[]{ "Values" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.AttributeProto.Types.RecordAttribute), global::ONNX.AttributeProto.Types.RecordAttribute.Parser, new[]{ "Name", "Domain", "Values" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.AttributeProto.Types.NullableAttribute), global::ONNX.AttributeProto.Types.NullableAttribute.Parser, new[]{ "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.AttributeProto.Types.SparseTensorAttribute), global::ONNX.AttributeProto.Types.SparseTensorAttribute.Parser, new[]{ "Dims", "DataType", "YaleFormat", "OneHot" }, new[]{ "Value" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.YaleFormatTensor), global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.YaleFormatTensor.Parser, new[]{ "NonZeroElements", "FirstIndices", "ColumnIndices" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.OneHotTensor), global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.OneHotTensor.Parser, new[]{ "LinearIndices" }, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.ValueInfoProto), global::ONNX.ValueInfoProto.Parser, new[]{ "Name", "Type", "DocString" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.NodeProto), global::ONNX.NodeProto.Parser, new[]{ "Input", "Output", "Name", "OpType", "Domain", "Attribute", "DocString" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.ModelProto), global::ONNX.ModelProto.Parser, new[]{ "IrVersion", "OpsetImport", "ProducerName", "ProducerVersion", "Domain", "ModelVersion", "DocString", "Graph", "MetadataProps", "ExternalModels" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.StringStringEntryProto), global::ONNX.StringStringEntryProto.Parser, new[]{ "Key", "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.GraphProto), global::ONNX.GraphProto.Parser, new[]{ "Node", "Name", "Initializer", "DocString", "Input", "Output", "ValueInfo" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TensorProto), global::ONNX.TensorProto.Parser, new[]{ "Dims", "DataType", "Segment", "FloatData", "Int32Data", "StringData", "Int64Data", "Name", "DocString", "RawData", "DoubleData", "Uint64Data" }, null, new[]{ typeof(global::ONNX.TensorProto.Types.DataType) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TensorProto.Types.Segment), global::ONNX.TensorProto.Types.Segment.Parser, new[]{ "Begin", "End" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TensorShapeProto), global::ONNX.TensorShapeProto.Parser, new[]{ "Dim" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TensorShapeProto.Types.Dimension), global::ONNX.TensorShapeProto.Types.Dimension.Parser, new[]{ "DimValue", "DimParam", "Denotation" }, new[]{ "Value" }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TypeProto), global::ONNX.TypeProto.Parser, new[]{ "TensorType", "SequenceType", "MapType", "TupleType", "OpaqueType", "SparseType", "RecordType", "NullableType", "ScalarType", "Denotation" }, new[]{ "Value" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TypeProto.Types.Tensor), global::ONNX.TypeProto.Types.Tensor.Parser, new[]{ "ElemType", "Shape" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TypeProto.Types.Scalar), global::ONNX.TypeProto.Types.Scalar.Parser, new[]{ "DataType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TypeProto.Types.Sequence), global::ONNX.TypeProto.Types.Sequence.Parser, new[]{ "ElemType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TypeProto.Types.Tuple), global::ONNX.TypeProto.Types.Tuple.Parser, new[]{ "ElemType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TypeProto.Types.Record), global::ONNX.TypeProto.Types.Record.Parser, new[]{ "Domain", "Name", "Fields" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TypeProto.Types.Opaque), global::ONNX.TypeProto.Types.Opaque.Parser, new[]{ "Domain", "Name" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TypeProto.Types.SparseTensor), global::ONNX.TypeProto.Types.SparseTensor.Parser, new[]{ "ElemType", "Shape" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TypeProto.Types.Nullable), global::ONNX.TypeProto.Types.Nullable.Parser, new[]{ "BaseType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.TypeProto.Types.Map), global::ONNX.TypeProto.Types.Map.Parser, new[]{ "KeyType", "ValueType" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.OperatorSetIdProto), global::ONNX.OperatorSetIdProto.Parser, new[]{ "Domain", "Version" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ONNX.ExternalModelProto), global::ONNX.ExternalModelProto.Parser, new[]{ "Domain", "Name", "Version" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// To be compatible with both proto2 and proto3, we will use a version number
  /// that is not defined by the default value but an explicit enum number.
  /// </summary>
  public enum Version {
    /// <summary>
    /// proto3 requires the first enum value to be zero.
    /// We add this just to appease the compiler.
    /// </summary>
    [pbr::OriginalName("_START_VERSION")] StartVersion = 0,
    /// <summary>
    /// The version field is always serialized and we will use it to store the
    /// version that the  graph is generated from. This helps us set up version
    /// control. We should use version as
    ///     xx(major) - xx(minor) - xxxx(bugfix)
    /// and we are starting with 0x00000001 (0.0.1), which was the
    ///  version we published on Oct 10, 2017.
    /// </summary>
    [pbr::OriginalName("IR_VERSION_2017_10_10")] IrVersion20171010 = 1,
    /// <summary>
    /// IR_VERSION 0.0.2 published on Oct 30, 2017
    /// - Added type discriminator to AttributeProto to support proto3 users
    /// </summary>
    [pbr::OriginalName("IR_VERSION_2017_10_30")] IrVersion20171030 = 2,
    /// <summary>
    /// IR VERSION 0.0.3 published on Nov 3, 2017
    /// - For operator versioning:
    ///    - Added new message OperatorSetIdProto
    ///    - Added opset_import in ModelProto
    /// - For vendor extensions, added domain in NodeProto
    /// </summary>
    [pbr::OriginalName("IR_VERSION_2017_11_03")] IrVersion20171103 = 3,
    /// <summary>
    /// IR VERSION 4 published on MM DD, 2018
    /// - For ONNX-ML:
    ///    - Added functions
    ///    - Added ONNX-ML types: records, tuples, scalar, 
    ///      sparse tensors, opaque.
    /// </summary>
    [pbr::OriginalName("IR_VERSION")] IrVersion = 4,
  }

  #endregion

  #region Messages
  /// <summary>
  /// A named attribute containing either singular float, integer, string
  /// and tensor values, or repeated float, integer, string and tensor values.
  /// An AttributeProto MUST contain the name field, and *only one* of the
  /// following content fields, effectively enforcing a C/C++ union equivalent.
  /// </summary>
  public sealed partial class AttributeProto : pb::IMessage<AttributeProto> {
    private static readonly pb::MessageParser<AttributeProto> _parser = new pb::MessageParser<AttributeProto>(() => new AttributeProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AttributeProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AttributeProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AttributeProto(AttributeProto other) : this() {
      name_ = other.name_;
      refAttrName_ = other.refAttrName_;
      docString_ = other.docString_;
      type_ = other.type_;
      f_ = other.f_;
      i_ = other.i_;
      s_ = other.s_;
      T = other.t_ != null ? other.T.Clone() : null;
      G = other.g_ != null ? other.G.Clone() : null;
      floats_ = other.floats_.Clone();
      ints_ = other.ints_.Clone();
      strings_ = other.strings_.Clone();
      tensors_ = other.tensors_.Clone();
      graphs_ = other.graphs_.Clone();
      Tuple = other.tuple_ != null ? other.Tuple.Clone() : null;
      Record = other.record_ != null ? other.Record.Clone() : null;
      Nullable = other.nullable_ != null ? other.Nullable.Clone() : null;
      Sparse = other.sparse_ != null ? other.Sparse.Clone() : null;
      typea_ = other.typea_;
      tuples_ = other.tuples_.Clone();
      records_ = other.records_.Clone();
      nullables_ = other.nullables_.Clone();
      sparses_ = other.sparses_.Clone();
      types_ = other.types_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AttributeProto Clone() {
      return new AttributeProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name field MUST be present for this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ref_attr_name" field.</summary>
    public const int RefAttrNameFieldNumber = 21;
    private string refAttrName_ = "";
    /// <summary>
    /// if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
    /// In this case, this AttributeProto does not contain data, and it's a reference of attribute
    /// in parent scope.
    /// NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RefAttrName {
      get { return refAttrName_; }
      set {
        refAttrName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 13;
    private string docString_ = "";
    /// <summary>
    /// A human-readable documentation for this attribute. Markdown is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 20;
    private global::ONNX.AttributeProto.Types.AttributeType type_ = 0;
    /// <summary>
    /// The type field MUST be present for this version of the IR.
    /// For 0.0.1 versions of the IR, this field was not defined, and
    /// implementations needed to use has_field hueristics to determine
    /// which value field was in use.  For IR_VERSION 0.0.2 or later, this
    /// field MUST be set and match the f|i|s|t|... field in use.  This
    /// change was made to accomodate proto3 implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.AttributeProto.Types.AttributeType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "f" field.</summary>
    public const int FFieldNumber = 2;
    private float f_;
    /// <summary>
    /// Exactly ONE of the following fields must be present for this version of the IR
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float F {
      get { return f_; }
      set {
        f_ = value;
      }
    }

    /// <summary>Field number for the "i" field.</summary>
    public const int IFieldNumber = 3;
    private long i_;
    /// <summary>
    /// int
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long I {
      get { return i_; }
      set {
        i_ = value;
      }
    }

    /// <summary>Field number for the "s" field.</summary>
    public const int SFieldNumber = 4;
    private pb::ByteString s_ = pb::ByteString.Empty;
    /// <summary>
    /// UTF-8 string
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString S {
      get { return s_; }
      set {
        s_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "t" field.</summary>
    public const int TFieldNumber = 5;
    private global::ONNX.TensorProto t_;
    /// <summary>
    /// tensor value
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TensorProto T {
      get { return t_; }
      set {
        t_ = value;
      }
    }

    /// <summary>Field number for the "g" field.</summary>
    public const int GFieldNumber = 6;
    private global::ONNX.GraphProto g_;
    /// <summary>
    /// graph
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.GraphProto G {
      get { return g_; }
      set {
        g_ = value;
      }
    }

    /// <summary>Field number for the "floats" field.</summary>
    public const int FloatsFieldNumber = 7;
    private static readonly pb::FieldCodec<float> _repeated_floats_codec
        = pb::FieldCodec.ForFloat(58);
    private readonly pbc::RepeatedField<float> floats_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// list of floats
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> Floats {
      get { return floats_; }
    }

    /// <summary>Field number for the "ints" field.</summary>
    public const int IntsFieldNumber = 8;
    private static readonly pb::FieldCodec<long> _repeated_ints_codec
        = pb::FieldCodec.ForInt64(66);
    private readonly pbc::RepeatedField<long> ints_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// list of ints
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Ints {
      get { return ints_; }
    }

    /// <summary>Field number for the "strings" field.</summary>
    public const int StringsFieldNumber = 9;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_strings_codec
        = pb::FieldCodec.ForBytes(74);
    private readonly pbc::RepeatedField<pb::ByteString> strings_ = new pbc::RepeatedField<pb::ByteString>();
    /// <summary>
    /// list of UTF-8 strings
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<pb::ByteString> Strings {
      get { return strings_; }
    }

    /// <summary>Field number for the "tensors" field.</summary>
    public const int TensorsFieldNumber = 10;
    private static readonly pb::FieldCodec<global::ONNX.TensorProto> _repeated_tensors_codec
        = pb::FieldCodec.ForMessage(82, global::ONNX.TensorProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.TensorProto> tensors_ = new pbc::RepeatedField<global::ONNX.TensorProto>();
    /// <summary>
    /// list of tensors
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.TensorProto> Tensors {
      get { return tensors_; }
    }

    /// <summary>Field number for the "graphs" field.</summary>
    public const int GraphsFieldNumber = 11;
    private static readonly pb::FieldCodec<global::ONNX.GraphProto> _repeated_graphs_codec
        = pb::FieldCodec.ForMessage(90, global::ONNX.GraphProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.GraphProto> graphs_ = new pbc::RepeatedField<global::ONNX.GraphProto>();
    /// <summary>
    /// list of graph
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.GraphProto> Graphs {
      get { return graphs_; }
    }

    /// <summary>Field number for the "tuple" field.</summary>
    public const int TupleFieldNumber = 100;
    private global::ONNX.AttributeProto.Types.TupleAttribute tuple_;
    /// <summary>
    /// A single tuple value
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.AttributeProto.Types.TupleAttribute Tuple {
      get { return tuple_; }
      set {
        tuple_ = value;
      }
    }

    /// <summary>Field number for the "record" field.</summary>
    public const int RecordFieldNumber = 101;
    private global::ONNX.AttributeProto.Types.RecordAttribute record_;
    /// <summary>
    /// A single record value
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.AttributeProto.Types.RecordAttribute Record {
      get { return record_; }
      set {
        record_ = value;
      }
    }

    /// <summary>Field number for the "nullable" field.</summary>
    public const int NullableFieldNumber = 102;
    private global::ONNX.AttributeProto.Types.NullableAttribute nullable_;
    /// <summary>
    /// A single nullable value
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.AttributeProto.Types.NullableAttribute Nullable {
      get { return nullable_; }
      set {
        nullable_ = value;
      }
    }

    /// <summary>Field number for the "sparse" field.</summary>
    public const int SparseFieldNumber = 103;
    private global::ONNX.AttributeProto.Types.SparseTensorAttribute sparse_;
    /// <summary>
    /// A single sparse tensor
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.AttributeProto.Types.SparseTensorAttribute Sparse {
      get { return sparse_; }
      set {
        sparse_ = value;
      }
    }

    /// <summary>Field number for the "typea" field.</summary>
    public const int TypeaFieldNumber = 104;
    private string typea_ = "";
    /// <summary>
    /// A single type
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Typea {
      get { return typea_; }
      set {
        typea_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "tuples" field.</summary>
    public const int TuplesFieldNumber = 105;
    private static readonly pb::FieldCodec<global::ONNX.AttributeProto.Types.TupleAttribute> _repeated_tuples_codec
        = pb::FieldCodec.ForMessage(842, global::ONNX.AttributeProto.Types.TupleAttribute.Parser);
    private readonly pbc::RepeatedField<global::ONNX.AttributeProto.Types.TupleAttribute> tuples_ = new pbc::RepeatedField<global::ONNX.AttributeProto.Types.TupleAttribute>();
    /// <summary>
    /// List of tuple values
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.AttributeProto.Types.TupleAttribute> Tuples {
      get { return tuples_; }
    }

    /// <summary>Field number for the "records" field.</summary>
    public const int RecordsFieldNumber = 106;
    private static readonly pb::FieldCodec<global::ONNX.AttributeProto.Types.RecordAttribute> _repeated_records_codec
        = pb::FieldCodec.ForMessage(850, global::ONNX.AttributeProto.Types.RecordAttribute.Parser);
    private readonly pbc::RepeatedField<global::ONNX.AttributeProto.Types.RecordAttribute> records_ = new pbc::RepeatedField<global::ONNX.AttributeProto.Types.RecordAttribute>();
    /// <summary>
    /// List of record values
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.AttributeProto.Types.RecordAttribute> Records {
      get { return records_; }
    }

    /// <summary>Field number for the "nullables" field.</summary>
    public const int NullablesFieldNumber = 107;
    private static readonly pb::FieldCodec<global::ONNX.AttributeProto.Types.NullableAttribute> _repeated_nullables_codec
        = pb::FieldCodec.ForMessage(858, global::ONNX.AttributeProto.Types.NullableAttribute.Parser);
    private readonly pbc::RepeatedField<global::ONNX.AttributeProto.Types.NullableAttribute> nullables_ = new pbc::RepeatedField<global::ONNX.AttributeProto.Types.NullableAttribute>();
    /// <summary>
    /// List of nullable values
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.AttributeProto.Types.NullableAttribute> Nullables {
      get { return nullables_; }
    }

    /// <summary>Field number for the "sparses" field.</summary>
    public const int SparsesFieldNumber = 108;
    private static readonly pb::FieldCodec<global::ONNX.AttributeProto.Types.SparseTensorAttribute> _repeated_sparses_codec
        = pb::FieldCodec.ForMessage(866, global::ONNX.AttributeProto.Types.SparseTensorAttribute.Parser);
    private readonly pbc::RepeatedField<global::ONNX.AttributeProto.Types.SparseTensorAttribute> sparses_ = new pbc::RepeatedField<global::ONNX.AttributeProto.Types.SparseTensorAttribute>();
    /// <summary>
    /// List of sparse tensors
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.AttributeProto.Types.SparseTensorAttribute> Sparses {
      get { return sparses_; }
    }

    /// <summary>Field number for the "types" field.</summary>
    public const int Types_FieldNumber = 109;
    private static readonly pb::FieldCodec<string> _repeated_types_codec
        = pb::FieldCodec.ForString(874);
    private readonly pbc::RepeatedField<string> types_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of types
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Types_ {
      get { return types_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AttributeProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AttributeProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (RefAttrName != other.RefAttrName) return false;
      if (DocString != other.DocString) return false;
      if (Type != other.Type) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(F, other.F)) return false;
      if (I != other.I) return false;
      if (S != other.S) return false;
      if (!object.Equals(T, other.T)) return false;
      if (!object.Equals(G, other.G)) return false;
      if(!floats_.Equals(other.floats_)) return false;
      if(!ints_.Equals(other.ints_)) return false;
      if(!strings_.Equals(other.strings_)) return false;
      if(!tensors_.Equals(other.tensors_)) return false;
      if(!graphs_.Equals(other.graphs_)) return false;
      if (!object.Equals(Tuple, other.Tuple)) return false;
      if (!object.Equals(Record, other.Record)) return false;
      if (!object.Equals(Nullable, other.Nullable)) return false;
      if (!object.Equals(Sparse, other.Sparse)) return false;
      if (Typea != other.Typea) return false;
      if(!tuples_.Equals(other.tuples_)) return false;
      if(!records_.Equals(other.records_)) return false;
      if(!nullables_.Equals(other.nullables_)) return false;
      if(!sparses_.Equals(other.sparses_)) return false;
      if(!types_.Equals(other.types_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (RefAttrName.Length != 0) hash ^= RefAttrName.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      if (F != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(F);
      if (I != 0L) hash ^= I.GetHashCode();
      if (S.Length != 0) hash ^= S.GetHashCode();
      if (t_ != null) hash ^= T.GetHashCode();
      if (g_ != null) hash ^= G.GetHashCode();
      hash ^= floats_.GetHashCode();
      hash ^= ints_.GetHashCode();
      hash ^= strings_.GetHashCode();
      hash ^= tensors_.GetHashCode();
      hash ^= graphs_.GetHashCode();
      if (tuple_ != null) hash ^= Tuple.GetHashCode();
      if (record_ != null) hash ^= Record.GetHashCode();
      if (nullable_ != null) hash ^= Nullable.GetHashCode();
      if (sparse_ != null) hash ^= Sparse.GetHashCode();
      if (Typea.Length != 0) hash ^= Typea.GetHashCode();
      hash ^= tuples_.GetHashCode();
      hash ^= records_.GetHashCode();
      hash ^= nullables_.GetHashCode();
      hash ^= sparses_.GetHashCode();
      hash ^= types_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (F != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(F);
      }
      if (I != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(I);
      }
      if (S.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(S);
      }
      if (t_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(T);
      }
      if (g_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(G);
      }
      floats_.WriteTo(output, _repeated_floats_codec);
      ints_.WriteTo(output, _repeated_ints_codec);
      strings_.WriteTo(output, _repeated_strings_codec);
      tensors_.WriteTo(output, _repeated_tensors_codec);
      graphs_.WriteTo(output, _repeated_graphs_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(DocString);
      }
      if (Type != 0) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) Type);
      }
      if (RefAttrName.Length != 0) {
        output.WriteRawTag(170, 1);
        output.WriteString(RefAttrName);
      }
      if (tuple_ != null) {
        output.WriteRawTag(162, 6);
        output.WriteMessage(Tuple);
      }
      if (record_ != null) {
        output.WriteRawTag(170, 6);
        output.WriteMessage(Record);
      }
      if (nullable_ != null) {
        output.WriteRawTag(178, 6);
        output.WriteMessage(Nullable);
      }
      if (sparse_ != null) {
        output.WriteRawTag(186, 6);
        output.WriteMessage(Sparse);
      }
      if (Typea.Length != 0) {
        output.WriteRawTag(194, 6);
        output.WriteString(Typea);
      }
      tuples_.WriteTo(output, _repeated_tuples_codec);
      records_.WriteTo(output, _repeated_records_codec);
      nullables_.WriteTo(output, _repeated_nullables_codec);
      sparses_.WriteTo(output, _repeated_sparses_codec);
      types_.WriteTo(output, _repeated_types_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (RefAttrName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(RefAttrName);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      if (Type != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (F != 0F) {
        size += 1 + 4;
      }
      if (I != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(I);
      }
      if (S.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(S);
      }
      if (t_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(T);
      }
      if (g_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(G);
      }
      size += floats_.CalculateSize(_repeated_floats_codec);
      size += ints_.CalculateSize(_repeated_ints_codec);
      size += strings_.CalculateSize(_repeated_strings_codec);
      size += tensors_.CalculateSize(_repeated_tensors_codec);
      size += graphs_.CalculateSize(_repeated_graphs_codec);
      if (tuple_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Tuple);
      }
      if (record_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Record);
      }
      if (nullable_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Nullable);
      }
      if (sparse_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Sparse);
      }
      if (Typea.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Typea);
      }
      size += tuples_.CalculateSize(_repeated_tuples_codec);
      size += records_.CalculateSize(_repeated_records_codec);
      size += nullables_.CalculateSize(_repeated_nullables_codec);
      size += sparses_.CalculateSize(_repeated_sparses_codec);
      size += types_.CalculateSize(_repeated_types_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AttributeProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.RefAttrName.Length != 0) {
        RefAttrName = other.RefAttrName;
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.F != 0F) {
        F = other.F;
      }
      if (other.I != 0L) {
        I = other.I;
      }
      if (other.S.Length != 0) {
        S = other.S;
      }
      if (other.t_ != null) {
        if (t_ == null) {
          t_ = new global::ONNX.TensorProto();
        }
        T.MergeFrom(other.T);
      }
      if (other.g_ != null) {
        if (g_ == null) {
          g_ = new global::ONNX.GraphProto();
        }
        G.MergeFrom(other.G);
      }
      floats_.Add(other.floats_);
      ints_.Add(other.ints_);
      strings_.Add(other.strings_);
      tensors_.Add(other.tensors_);
      graphs_.Add(other.graphs_);
      if (other.tuple_ != null) {
        if (tuple_ == null) {
          tuple_ = new global::ONNX.AttributeProto.Types.TupleAttribute();
        }
        Tuple.MergeFrom(other.Tuple);
      }
      if (other.record_ != null) {
        if (record_ == null) {
          record_ = new global::ONNX.AttributeProto.Types.RecordAttribute();
        }
        Record.MergeFrom(other.Record);
      }
      if (other.nullable_ != null) {
        if (nullable_ == null) {
          nullable_ = new global::ONNX.AttributeProto.Types.NullableAttribute();
        }
        Nullable.MergeFrom(other.Nullable);
      }
      if (other.sparse_ != null) {
        if (sparse_ == null) {
          sparse_ = new global::ONNX.AttributeProto.Types.SparseTensorAttribute();
        }
        Sparse.MergeFrom(other.Sparse);
      }
      if (other.Typea.Length != 0) {
        Typea = other.Typea;
      }
      tuples_.Add(other.tuples_);
      records_.Add(other.records_);
      nullables_.Add(other.nullables_);
      sparses_.Add(other.sparses_);
      types_.Add(other.types_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 21: {
            F = input.ReadFloat();
            break;
          }
          case 24: {
            I = input.ReadInt64();
            break;
          }
          case 34: {
            S = input.ReadBytes();
            break;
          }
          case 42: {
            if (t_ == null) {
              t_ = new global::ONNX.TensorProto();
            }
            input.ReadMessage(t_);
            break;
          }
          case 50: {
            if (g_ == null) {
              g_ = new global::ONNX.GraphProto();
            }
            input.ReadMessage(g_);
            break;
          }
          case 58:
          case 61: {
            floats_.AddEntriesFrom(input, _repeated_floats_codec);
            break;
          }
          case 66:
          case 64: {
            ints_.AddEntriesFrom(input, _repeated_ints_codec);
            break;
          }
          case 74: {
            strings_.AddEntriesFrom(input, _repeated_strings_codec);
            break;
          }
          case 82: {
            tensors_.AddEntriesFrom(input, _repeated_tensors_codec);
            break;
          }
          case 90: {
            graphs_.AddEntriesFrom(input, _repeated_graphs_codec);
            break;
          }
          case 106: {
            DocString = input.ReadString();
            break;
          }
          case 160: {
            type_ = (global::ONNX.AttributeProto.Types.AttributeType) input.ReadEnum();
            break;
          }
          case 170: {
            RefAttrName = input.ReadString();
            break;
          }
          case 802: {
            if (tuple_ == null) {
              tuple_ = new global::ONNX.AttributeProto.Types.TupleAttribute();
            }
            input.ReadMessage(tuple_);
            break;
          }
          case 810: {
            if (record_ == null) {
              record_ = new global::ONNX.AttributeProto.Types.RecordAttribute();
            }
            input.ReadMessage(record_);
            break;
          }
          case 818: {
            if (nullable_ == null) {
              nullable_ = new global::ONNX.AttributeProto.Types.NullableAttribute();
            }
            input.ReadMessage(nullable_);
            break;
          }
          case 826: {
            if (sparse_ == null) {
              sparse_ = new global::ONNX.AttributeProto.Types.SparseTensorAttribute();
            }
            input.ReadMessage(sparse_);
            break;
          }
          case 834: {
            Typea = input.ReadString();
            break;
          }
          case 842: {
            tuples_.AddEntriesFrom(input, _repeated_tuples_codec);
            break;
          }
          case 850: {
            records_.AddEntriesFrom(input, _repeated_records_codec);
            break;
          }
          case 858: {
            nullables_.AddEntriesFrom(input, _repeated_nullables_codec);
            break;
          }
          case 866: {
            sparses_.AddEntriesFrom(input, _repeated_sparses_codec);
            break;
          }
          case 874: {
            types_.AddEntriesFrom(input, _repeated_types_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the AttributeProto message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Note: this enum is structurally identical to the OpSchema::AttrType
      /// enum defined in schema.h.  If you rev one, you likely need to rev the other.
      /// </summary>
      public enum AttributeType {
        [pbr::OriginalName("UNDEFINED")] Undefined = 0,
        [pbr::OriginalName("FLOAT")] Float = 1,
        [pbr::OriginalName("INT")] Int = 2,
        [pbr::OriginalName("STRING")] String = 3,
        [pbr::OriginalName("TENSOR")] Tensor = 4,
        [pbr::OriginalName("GRAPH")] Graph = 5,
        [pbr::OriginalName("FLOATS")] Floats = 6,
        [pbr::OriginalName("INTS")] Ints = 7,
        [pbr::OriginalName("STRINGS")] Strings = 8,
        [pbr::OriginalName("TENSORS")] Tensors = 9,
        [pbr::OriginalName("GRAPHS")] Graphs = 10,
        [pbr::OriginalName("TUPLE")] Tuple = 11,
        [pbr::OriginalName("RECORD")] Record = 12,
        [pbr::OriginalName("NULLABLE")] Nullable = 13,
        [pbr::OriginalName("SPARSE")] Sparse = 14,
        [pbr::OriginalName("TYPE")] Type = 15,
        [pbr::OriginalName("TUPLES")] Tuples = 16,
        [pbr::OriginalName("RECORDS")] Records = 17,
        [pbr::OriginalName("NULLABLES")] Nullables = 18,
        [pbr::OriginalName("SPARSES")] Sparses = 19,
        [pbr::OriginalName("TYPES")] Types = 20,
      }

      public sealed partial class TupleAttribute : pb::IMessage<TupleAttribute> {
        private static readonly pb::MessageParser<TupleAttribute> _parser = new pb::MessageParser<TupleAttribute>(() => new TupleAttribute());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TupleAttribute> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.AttributeProto.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleAttribute() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleAttribute(TupleAttribute other) : this() {
          values_ = other.values_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleAttribute Clone() {
          return new TupleAttribute(this);
        }

        /// <summary>Field number for the "values" field.</summary>
        public const int ValuesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::ONNX.AttributeProto> _repeated_values_codec
            = pb::FieldCodec.ForMessage(10, global::ONNX.AttributeProto.Parser);
        private readonly pbc::RepeatedField<global::ONNX.AttributeProto> values_ = new pbc::RepeatedField<global::ONNX.AttributeProto>();
        /// <summary>
        /// The tuple elements, represented as a series of attributes. If present,
        /// any attribute names are ignored.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::ONNX.AttributeProto> Values {
          get { return values_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TupleAttribute);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TupleAttribute other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!values_.Equals(other.values_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= values_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          values_.WriteTo(output, _repeated_values_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += values_.CalculateSize(_repeated_values_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TupleAttribute other) {
          if (other == null) {
            return;
          }
          values_.Add(other.values_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                values_.AddEntriesFrom(input, _repeated_values_codec);
                break;
              }
            }
          }
        }

      }

      public sealed partial class RecordAttribute : pb::IMessage<RecordAttribute> {
        private static readonly pb::MessageParser<RecordAttribute> _parser = new pb::MessageParser<RecordAttribute>(() => new RecordAttribute());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RecordAttribute> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.AttributeProto.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RecordAttribute() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RecordAttribute(RecordAttribute other) : this() {
          name_ = other.name_;
          domain_ = other.domain_;
          values_ = other.values_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RecordAttribute Clone() {
          return new RecordAttribute(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The name of the record type this attribute corresponds to.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "domain" field.</summary>
        public const int DomainFieldNumber = 2;
        private string domain_ = "";
        /// <summary>
        /// The domain of the record type this attribute corresponds to.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Domain {
          get { return domain_; }
          set {
            domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "values" field.</summary>
        public const int ValuesFieldNumber = 3;
        private static readonly pb::FieldCodec<global::ONNX.AttributeProto> _repeated_values_codec
            = pb::FieldCodec.ForMessage(26, global::ONNX.AttributeProto.Parser);
        private readonly pbc::RepeatedField<global::ONNX.AttributeProto> values_ = new pbc::RepeatedField<global::ONNX.AttributeProto>();
        /// <summary>
        /// The fields, represented as a series of attributes. The names of the 
        /// attributes MUST correspond to the respective field names of the record type.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::ONNX.AttributeProto> Values {
          get { return values_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RecordAttribute);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RecordAttribute other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Domain != other.Domain) return false;
          if(!values_.Equals(other.values_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (Domain.Length != 0) hash ^= Domain.GetHashCode();
          hash ^= values_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (Domain.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Domain);
          }
          values_.WriteTo(output, _repeated_values_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (Domain.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
          }
          size += values_.CalculateSize(_repeated_values_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RecordAttribute other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.Domain.Length != 0) {
            Domain = other.Domain;
          }
          values_.Add(other.values_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                Domain = input.ReadString();
                break;
              }
              case 26: {
                values_.AddEntriesFrom(input, _repeated_values_codec);
                break;
              }
            }
          }
        }

      }

      public sealed partial class NullableAttribute : pb::IMessage<NullableAttribute> {
        private static readonly pb::MessageParser<NullableAttribute> _parser = new pb::MessageParser<NullableAttribute>(() => new NullableAttribute());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<NullableAttribute> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.AttributeProto.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NullableAttribute() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NullableAttribute(NullableAttribute other) : this() {
          Value = other.value_ != null ? other.Value.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NullableAttribute Clone() {
          return new NullableAttribute(this);
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 1;
        private global::ONNX.AttributeProto value_;
        /// <summary>
        /// The optional value. If present, an attribute name is ignored.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.AttributeProto Value {
          get { return value_; }
          set {
            value_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as NullableAttribute);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(NullableAttribute other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Value, other.Value)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (value_ != null) hash ^= Value.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (value_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (value_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Value);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(NullableAttribute other) {
          if (other == null) {
            return;
          }
          if (other.value_ != null) {
            if (value_ == null) {
              value_ = new global::ONNX.AttributeProto();
            }
            Value.MergeFrom(other.Value);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (value_ == null) {
                  value_ = new global::ONNX.AttributeProto();
                }
                input.ReadMessage(value_);
                break;
              }
            }
          }
        }

      }

      public sealed partial class SparseTensorAttribute : pb::IMessage<SparseTensorAttribute> {
        private static readonly pb::MessageParser<SparseTensorAttribute> _parser = new pb::MessageParser<SparseTensorAttribute>(() => new SparseTensorAttribute());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SparseTensorAttribute> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.AttributeProto.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensorAttribute() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensorAttribute(SparseTensorAttribute other) : this() {
          dims_ = other.dims_.Clone();
          dataType_ = other.dataType_;
          switch (other.ValueCase) {
            case ValueOneofCase.YaleFormat:
              YaleFormat = other.YaleFormat.Clone();
              break;
            case ValueOneofCase.OneHot:
              OneHot = other.OneHot.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensorAttribute Clone() {
          return new SparseTensorAttribute(this);
        }

        /// <summary>Field number for the "dims" field.</summary>
        public const int DimsFieldNumber = 1;
        private static readonly pb::FieldCodec<long> _repeated_dims_codec
            = pb::FieldCodec.ForInt64(10);
        private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
        /// <summary>
        /// The shape of the tensor.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> Dims {
          get { return dims_; }
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 2;
        private global::ONNX.TensorProto.Types.DataType dataType_ = 0;
        /// <summary>
        /// The data type of the tensor.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorProto.Types.DataType DataType {
          get { return dataType_; }
          set {
            dataType_ = value;
          }
        }

        /// <summary>Field number for the "yale_format" field.</summary>
        public const int YaleFormatFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.YaleFormatTensor YaleFormat {
          get { return valueCase_ == ValueOneofCase.YaleFormat ? (global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.YaleFormatTensor) value_ : null; }
          set {
            value_ = value;
            valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.YaleFormat;
          }
        }

        /// <summary>Field number for the "one_hot" field.</summary>
        public const int OneHotFieldNumber = 4;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.OneHotTensor OneHot {
          get { return valueCase_ == ValueOneofCase.OneHot ? (global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.OneHotTensor) value_ : null; }
          set {
            value_ = value;
            valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.OneHot;
          }
        }

        private object value_;
        /// <summary>Enum of possible cases for the "value" oneof.</summary>
        public enum ValueOneofCase {
          None = 0,
          YaleFormat = 3,
          OneHot = 4,
        }
        private ValueOneofCase valueCase_ = ValueOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ValueOneofCase ValueCase {
          get { return valueCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearValue() {
          valueCase_ = ValueOneofCase.None;
          value_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SparseTensorAttribute);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SparseTensorAttribute other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!dims_.Equals(other.dims_)) return false;
          if (DataType != other.DataType) return false;
          if (!object.Equals(YaleFormat, other.YaleFormat)) return false;
          if (!object.Equals(OneHot, other.OneHot)) return false;
          if (ValueCase != other.ValueCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= dims_.GetHashCode();
          if (DataType != 0) hash ^= DataType.GetHashCode();
          if (valueCase_ == ValueOneofCase.YaleFormat) hash ^= YaleFormat.GetHashCode();
          if (valueCase_ == ValueOneofCase.OneHot) hash ^= OneHot.GetHashCode();
          hash ^= (int) valueCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          dims_.WriteTo(output, _repeated_dims_codec);
          if (DataType != 0) {
            output.WriteRawTag(16);
            output.WriteEnum((int) DataType);
          }
          if (valueCase_ == ValueOneofCase.YaleFormat) {
            output.WriteRawTag(26);
            output.WriteMessage(YaleFormat);
          }
          if (valueCase_ == ValueOneofCase.OneHot) {
            output.WriteRawTag(34);
            output.WriteMessage(OneHot);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += dims_.CalculateSize(_repeated_dims_codec);
          if (DataType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
          }
          if (valueCase_ == ValueOneofCase.YaleFormat) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(YaleFormat);
          }
          if (valueCase_ == ValueOneofCase.OneHot) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OneHot);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SparseTensorAttribute other) {
          if (other == null) {
            return;
          }
          dims_.Add(other.dims_);
          if (other.DataType != 0) {
            DataType = other.DataType;
          }
          switch (other.ValueCase) {
            case ValueOneofCase.YaleFormat:
              if (YaleFormat == null) {
                YaleFormat = new global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.YaleFormatTensor();
              }
              YaleFormat.MergeFrom(other.YaleFormat);
              break;
            case ValueOneofCase.OneHot:
              if (OneHot == null) {
                OneHot = new global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.OneHotTensor();
              }
              OneHot.MergeFrom(other.OneHot);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10:
              case 8: {
                dims_.AddEntriesFrom(input, _repeated_dims_codec);
                break;
              }
              case 16: {
                dataType_ = (global::ONNX.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
              case 26: {
                global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.YaleFormatTensor subBuilder = new global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.YaleFormatTensor();
                if (valueCase_ == ValueOneofCase.YaleFormat) {
                  subBuilder.MergeFrom(YaleFormat);
                }
                input.ReadMessage(subBuilder);
                YaleFormat = subBuilder;
                break;
              }
              case 34: {
                global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.OneHotTensor subBuilder = new global::ONNX.AttributeProto.Types.SparseTensorAttribute.Types.OneHotTensor();
                if (valueCase_ == ValueOneofCase.OneHot) {
                  subBuilder.MergeFrom(OneHot);
                }
                input.ReadMessage(subBuilder);
                OneHot = subBuilder;
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the SparseTensorAttribute message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public sealed partial class YaleFormatTensor : pb::IMessage<YaleFormatTensor> {
            private static readonly pb::MessageParser<YaleFormatTensor> _parser = new pb::MessageParser<YaleFormatTensor>(() => new YaleFormatTensor());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<YaleFormatTensor> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::ONNX.AttributeProto.Types.SparseTensorAttribute.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public YaleFormatTensor() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public YaleFormatTensor(YaleFormatTensor other) : this() {
              NonZeroElements = other.nonZeroElements_ != null ? other.NonZeroElements.Clone() : null;
              firstIndices_ = other.firstIndices_.Clone();
              columnIndices_ = other.columnIndices_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public YaleFormatTensor Clone() {
              return new YaleFormatTensor(this);
            }

            /// <summary>Field number for the "non_zero_elements" field.</summary>
            public const int NonZeroElementsFieldNumber = 1;
            private global::ONNX.TensorProto nonZeroElements_;
            /// <summary>
            /// Sparse tensors are stored using the CSR (Yale) format, which is is described at: 
            /// https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format).
            ///
            /// The data type of the tensor elements are determined from the 'A' tensor, which holds the non-zero elements.
            /// Note that for the purposes of encoding, only the first dimension is compressed, the rest are treated as 
            /// if the tensor were of two dimensions.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::ONNX.TensorProto NonZeroElements {
              get { return nonZeroElements_; }
              set {
                nonZeroElements_ = value;
              }
            }

            /// <summary>Field number for the "first_indices" field.</summary>
            public const int FirstIndicesFieldNumber = 2;
            private static readonly pb::FieldCodec<long> _repeated_firstIndices_codec
                = pb::FieldCodec.ForInt64(18);
            private readonly pbc::RepeatedField<long> firstIndices_ = new pbc::RepeatedField<long>();
            /// <summary>
            /// This is the IA array, which stores the index in NZE of the
            /// first non-zero element in row i. If there are m rows, this
            /// array is m+1 elements long.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<long> FirstIndices {
              get { return firstIndices_; }
            }

            /// <summary>Field number for the "column_indices" field.</summary>
            public const int ColumnIndicesFieldNumber = 3;
            private static readonly pb::FieldCodec<long> _repeated_columnIndices_codec
                = pb::FieldCodec.ForInt64(26);
            private readonly pbc::RepeatedField<long> columnIndices_ = new pbc::RepeatedField<long>();
            /// <summary>
            /// This is the JA array, which stores the column index of
            /// each element. It must be the same length as the NZE tensor.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<long> ColumnIndices {
              get { return columnIndices_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as YaleFormatTensor);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(YaleFormatTensor other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(NonZeroElements, other.NonZeroElements)) return false;
              if(!firstIndices_.Equals(other.firstIndices_)) return false;
              if(!columnIndices_.Equals(other.columnIndices_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (nonZeroElements_ != null) hash ^= NonZeroElements.GetHashCode();
              hash ^= firstIndices_.GetHashCode();
              hash ^= columnIndices_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (nonZeroElements_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(NonZeroElements);
              }
              firstIndices_.WriteTo(output, _repeated_firstIndices_codec);
              columnIndices_.WriteTo(output, _repeated_columnIndices_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (nonZeroElements_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(NonZeroElements);
              }
              size += firstIndices_.CalculateSize(_repeated_firstIndices_codec);
              size += columnIndices_.CalculateSize(_repeated_columnIndices_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(YaleFormatTensor other) {
              if (other == null) {
                return;
              }
              if (other.nonZeroElements_ != null) {
                if (nonZeroElements_ == null) {
                  nonZeroElements_ = new global::ONNX.TensorProto();
                }
                NonZeroElements.MergeFrom(other.NonZeroElements);
              }
              firstIndices_.Add(other.firstIndices_);
              columnIndices_.Add(other.columnIndices_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (nonZeroElements_ == null) {
                      nonZeroElements_ = new global::ONNX.TensorProto();
                    }
                    input.ReadMessage(nonZeroElements_);
                    break;
                  }
                  case 18:
                  case 16: {
                    firstIndices_.AddEntriesFrom(input, _repeated_firstIndices_codec);
                    break;
                  }
                  case 26:
                  case 24: {
                    columnIndices_.AddEntriesFrom(input, _repeated_columnIndices_codec);
                    break;
                  }
                }
              }
            }

          }

          public sealed partial class OneHotTensor : pb::IMessage<OneHotTensor> {
            private static readonly pb::MessageParser<OneHotTensor> _parser = new pb::MessageParser<OneHotTensor>(() => new OneHotTensor());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<OneHotTensor> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::ONNX.AttributeProto.Types.SparseTensorAttribute.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public OneHotTensor() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public OneHotTensor(OneHotTensor other) : this() {
              linearIndices_ = other.linearIndices_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public OneHotTensor Clone() {
              return new OneHotTensor(this);
            }

            /// <summary>Field number for the "linear_indices" field.</summary>
            public const int LinearIndicesFieldNumber = 1;
            private static readonly pb::FieldCodec<long> _repeated_linearIndices_codec
                = pb::FieldCodec.ForInt64(10);
            private readonly pbc::RepeatedField<long> linearIndices_ = new pbc::RepeatedField<long>();
            /// <summary>
            /// For tensors that are rows (or a higher numbers of dimensions) of one-hot-encoded
            /// features, the linear indices where the 1-values are found are listed here.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<long> LinearIndices {
              get { return linearIndices_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as OneHotTensor);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(OneHotTensor other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!linearIndices_.Equals(other.linearIndices_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= linearIndices_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              linearIndices_.WriteTo(output, _repeated_linearIndices_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              size += linearIndices_.CalculateSize(_repeated_linearIndices_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(OneHotTensor other) {
              if (other == null) {
                return;
              }
              linearIndices_.Add(other.linearIndices_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10:
                  case 8: {
                    linearIndices_.AddEntriesFrom(input, _repeated_linearIndices_codec);
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Defines information on value, including the name, the type, and
  /// the shape of the value.
  /// </summary>
  public sealed partial class ValueInfoProto : pb::IMessage<ValueInfoProto> {
    private static readonly pb::MessageParser<ValueInfoProto> _parser = new pb::MessageParser<ValueInfoProto>(() => new ValueInfoProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ValueInfoProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueInfoProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueInfoProto(ValueInfoProto other) : this() {
      name_ = other.name_;
      Type = other.type_ != null ? other.Type.Clone() : null;
      docString_ = other.docString_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueInfoProto Clone() {
      return new ValueInfoProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// This field MUST be present in this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::ONNX.TypeProto type_;
    /// <summary>
    /// This field MUST be present in this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TypeProto Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 3;
    private string docString_ = "";
    /// <summary>
    /// A human-readable documentation for this value. Markdown is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ValueInfoProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ValueInfoProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Type, other.Type)) return false;
      if (DocString != other.DocString) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (type_ != null) hash ^= Type.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (type_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Type);
      }
      if (DocString.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DocString);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (type_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Type);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ValueInfoProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.type_ != null) {
        if (type_ == null) {
          type_ = new global::ONNX.TypeProto();
        }
        Type.MergeFrom(other.Type);
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (type_ == null) {
              type_ = new global::ONNX.TypeProto();
            }
            input.ReadMessage(type_);
            break;
          }
          case 26: {
            DocString = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// NodeProto stores a node that is similar to the notion of "layer"
  /// or "operator" in many deep learning frameworks. For example, it can be a
  /// node of type "Conv" that takes in an image, a filter tensor and a bias
  /// tensor, and produces the convolved output.
  /// </summary>
  public sealed partial class NodeProto : pb::IMessage<NodeProto> {
    private static readonly pb::MessageParser<NodeProto> _parser = new pb::MessageParser<NodeProto>(() => new NodeProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeProto(NodeProto other) : this() {
      input_ = other.input_.Clone();
      output_ = other.output_.Clone();
      name_ = other.name_;
      opType_ = other.opType_;
      domain_ = other.domain_;
      attribute_ = other.attribute_.Clone();
      docString_ = other.docString_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeProto Clone() {
      return new NodeProto(this);
    }

    /// <summary>Field number for the "input" field.</summary>
    public const int InputFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_input_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> input_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// namespace Value
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Input {
      get { return input_; }
    }

    /// <summary>Field number for the "output" field.</summary>
    public const int OutputFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_output_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> output_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// namespace Value
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Output {
      get { return output_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// An optional identifier for this node in a graph.
    /// This field MAY be absent in ths version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "op_type" field.</summary>
    public const int OpTypeFieldNumber = 4;
    private string opType_ = "";
    /// <summary>
    /// The symbolic identifier of the Operator to execute.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OpType {
      get { return opType_; }
      set {
        opType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "domain" field.</summary>
    public const int DomainFieldNumber = 7;
    private string domain_ = "";
    /// <summary>
    /// The domain of the OperatorSet that specifies the operator named by op_type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Domain {
      get { return domain_; }
      set {
        domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "attribute" field.</summary>
    public const int AttributeFieldNumber = 5;
    private static readonly pb::FieldCodec<global::ONNX.AttributeProto> _repeated_attribute_codec
        = pb::FieldCodec.ForMessage(42, global::ONNX.AttributeProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.AttributeProto> attribute_ = new pbc::RepeatedField<global::ONNX.AttributeProto>();
    /// <summary>
    /// Additional named attributes.
    /// NOTE: Simply using ValueProto.NameValuePairProto is the most general
    ///       solution.  I kept AttributeProto to minimize churn on CI results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.AttributeProto> Attribute {
      get { return attribute_; }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 6;
    private string docString_ = "";
    /// <summary>
    /// A human-readable documentation for this node. Markdown is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!input_.Equals(other.input_)) return false;
      if(!output_.Equals(other.output_)) return false;
      if (Name != other.Name) return false;
      if (OpType != other.OpType) return false;
      if (Domain != other.Domain) return false;
      if(!attribute_.Equals(other.attribute_)) return false;
      if (DocString != other.DocString) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= input_.GetHashCode();
      hash ^= output_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (OpType.Length != 0) hash ^= OpType.GetHashCode();
      if (Domain.Length != 0) hash ^= Domain.GetHashCode();
      hash ^= attribute_.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      input_.WriteTo(output, _repeated_input_codec);
      output_.WriteTo(output, _repeated_output_codec);
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (OpType.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(OpType);
      }
      attribute_.WriteTo(output, _repeated_attribute_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(DocString);
      }
      if (Domain.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(Domain);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += input_.CalculateSize(_repeated_input_codec);
      size += output_.CalculateSize(_repeated_output_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (OpType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OpType);
      }
      if (Domain.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
      }
      size += attribute_.CalculateSize(_repeated_attribute_codec);
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeProto other) {
      if (other == null) {
        return;
      }
      input_.Add(other.input_);
      output_.Add(other.output_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.OpType.Length != 0) {
        OpType = other.OpType;
      }
      if (other.Domain.Length != 0) {
        Domain = other.Domain;
      }
      attribute_.Add(other.attribute_);
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            input_.AddEntriesFrom(input, _repeated_input_codec);
            break;
          }
          case 18: {
            output_.AddEntriesFrom(input, _repeated_output_codec);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            OpType = input.ReadString();
            break;
          }
          case 42: {
            attribute_.AddEntriesFrom(input, _repeated_attribute_codec);
            break;
          }
          case 50: {
            DocString = input.ReadString();
            break;
          }
          case 58: {
            Domain = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// ModelProto is a top-level file/container format for bundling a ML model.
  /// The semantics of the model are described by the GraphProto that represents
  /// a parameterized computation graph against a set of named operators that are
  /// defined independently from the graph.
  /// </summary>
  public sealed partial class ModelProto : pb::IMessage<ModelProto> {
    private static readonly pb::MessageParser<ModelProto> _parser = new pb::MessageParser<ModelProto>(() => new ModelProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelProto(ModelProto other) : this() {
      irVersion_ = other.irVersion_;
      opsetImport_ = other.opsetImport_.Clone();
      producerName_ = other.producerName_;
      producerVersion_ = other.producerVersion_;
      domain_ = other.domain_;
      modelVersion_ = other.modelVersion_;
      docString_ = other.docString_;
      Graph = other.graph_ != null ? other.Graph.Clone() : null;
      metadataProps_ = other.metadataProps_.Clone();
      externalModels_ = other.externalModels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelProto Clone() {
      return new ModelProto(this);
    }

    /// <summary>Field number for the "ir_version" field.</summary>
    public const int IrVersionFieldNumber = 1;
    private long irVersion_;
    /// <summary>
    /// The version of the IR this model targets. See Version enum above.
    /// This field MUST be present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IrVersion {
      get { return irVersion_; }
      set {
        irVersion_ = value;
      }
    }

    /// <summary>Field number for the "opset_import" field.</summary>
    public const int OpsetImportFieldNumber = 8;
    private static readonly pb::FieldCodec<global::ONNX.OperatorSetIdProto> _repeated_opsetImport_codec
        = pb::FieldCodec.ForMessage(66, global::ONNX.OperatorSetIdProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.OperatorSetIdProto> opsetImport_ = new pbc::RepeatedField<global::ONNX.OperatorSetIdProto>();
    /// <summary>
    /// The OperatorSets this model relies on.
    /// All ModelProtos MUST have at least one entry that
    /// specifies which version of the ONNX OperatorSet is
    /// being imported.
    ///
    /// All nodes in the ModelProto's graph will bind against the operator
    /// with the same-domain/same-op_type operator with the HIGHEST version
    /// in the referenced operator sets.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.OperatorSetIdProto> OpsetImport {
      get { return opsetImport_; }
    }

    /// <summary>Field number for the "producer_name" field.</summary>
    public const int ProducerNameFieldNumber = 2;
    private string producerName_ = "";
    /// <summary>
    /// The name of the framework or tool used to generate this model.
    /// This field SHOULD be present to indicate which implementation/tool/framework
    /// emitted the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProducerName {
      get { return producerName_; }
      set {
        producerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "producer_version" field.</summary>
    public const int ProducerVersionFieldNumber = 3;
    private string producerVersion_ = "";
    /// <summary>
    /// The version of the framework or tool used to generate this model.
    /// This field SHOULD be present to indicate which implementation/tool/framework
    /// emitted the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProducerVersion {
      get { return producerVersion_; }
      set {
        producerVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "domain" field.</summary>
    public const int DomainFieldNumber = 4;
    private string domain_ = "";
    /// <summary>
    /// Domain name of the model.
    /// We use reverse domain names as name space indicators. For example:
    /// `com.facebook.fair` or `com.microsoft.cognitiveservices`
    ///
    /// Together with `model_version` and GraphProto.name, this forms the unique identity of
    /// the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Domain {
      get { return domain_; }
      set {
        domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_version" field.</summary>
    public const int ModelVersionFieldNumber = 5;
    private long modelVersion_;
    /// <summary>
    /// The version of the graph encoded. See Version enum below.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ModelVersion {
      get { return modelVersion_; }
      set {
        modelVersion_ = value;
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 6;
    private string docString_ = "";
    /// <summary>
    /// A human-readable documentation for this model. Markdown is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "graph" field.</summary>
    public const int GraphFieldNumber = 7;
    private global::ONNX.GraphProto graph_;
    /// <summary>
    /// The parameterized graph that is evaluated to execute the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.GraphProto Graph {
      get { return graph_; }
      set {
        graph_ = value;
      }
    }

    /// <summary>Field number for the "metadata_props" field.</summary>
    public const int MetadataPropsFieldNumber = 14;
    private static readonly pb::FieldCodec<global::ONNX.StringStringEntryProto> _repeated_metadataProps_codec
        = pb::FieldCodec.ForMessage(114, global::ONNX.StringStringEntryProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.StringStringEntryProto> metadataProps_ = new pbc::RepeatedField<global::ONNX.StringStringEntryProto>();
    /// <summary>
    /// Named metadata values; keys should be distinct.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.StringStringEntryProto> MetadataProps {
      get { return metadataProps_; }
    }

    /// <summary>Field number for the "external_models" field.</summary>
    public const int ExternalModelsFieldNumber = 15;
    private static readonly pb::FieldCodec<global::ONNX.ExternalModelProto> _repeated_externalModels_codec
        = pb::FieldCodec.ForMessage(122, global::ONNX.ExternalModelProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.ExternalModelProto> externalModels_ = new pbc::RepeatedField<global::ONNX.ExternalModelProto>();
    /// <summary>
    /// External models imported to this model for use as custom operators.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.ExternalModelProto> ExternalModels {
      get { return externalModels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IrVersion != other.IrVersion) return false;
      if(!opsetImport_.Equals(other.opsetImport_)) return false;
      if (ProducerName != other.ProducerName) return false;
      if (ProducerVersion != other.ProducerVersion) return false;
      if (Domain != other.Domain) return false;
      if (ModelVersion != other.ModelVersion) return false;
      if (DocString != other.DocString) return false;
      if (!object.Equals(Graph, other.Graph)) return false;
      if(!metadataProps_.Equals(other.metadataProps_)) return false;
      if(!externalModels_.Equals(other.externalModels_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (IrVersion != 0L) hash ^= IrVersion.GetHashCode();
      hash ^= opsetImport_.GetHashCode();
      if (ProducerName.Length != 0) hash ^= ProducerName.GetHashCode();
      if (ProducerVersion.Length != 0) hash ^= ProducerVersion.GetHashCode();
      if (Domain.Length != 0) hash ^= Domain.GetHashCode();
      if (ModelVersion != 0L) hash ^= ModelVersion.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      if (graph_ != null) hash ^= Graph.GetHashCode();
      hash ^= metadataProps_.GetHashCode();
      hash ^= externalModels_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (IrVersion != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(IrVersion);
      }
      if (ProducerName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProducerName);
      }
      if (ProducerVersion.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ProducerVersion);
      }
      if (Domain.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Domain);
      }
      if (ModelVersion != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(ModelVersion);
      }
      if (DocString.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(DocString);
      }
      if (graph_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Graph);
      }
      opsetImport_.WriteTo(output, _repeated_opsetImport_codec);
      metadataProps_.WriteTo(output, _repeated_metadataProps_codec);
      externalModels_.WriteTo(output, _repeated_externalModels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (IrVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IrVersion);
      }
      size += opsetImport_.CalculateSize(_repeated_opsetImport_codec);
      if (ProducerName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProducerName);
      }
      if (ProducerVersion.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProducerVersion);
      }
      if (Domain.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
      }
      if (ModelVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ModelVersion);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      if (graph_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Graph);
      }
      size += metadataProps_.CalculateSize(_repeated_metadataProps_codec);
      size += externalModels_.CalculateSize(_repeated_externalModels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelProto other) {
      if (other == null) {
        return;
      }
      if (other.IrVersion != 0L) {
        IrVersion = other.IrVersion;
      }
      opsetImport_.Add(other.opsetImport_);
      if (other.ProducerName.Length != 0) {
        ProducerName = other.ProducerName;
      }
      if (other.ProducerVersion.Length != 0) {
        ProducerVersion = other.ProducerVersion;
      }
      if (other.Domain.Length != 0) {
        Domain = other.Domain;
      }
      if (other.ModelVersion != 0L) {
        ModelVersion = other.ModelVersion;
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      if (other.graph_ != null) {
        if (graph_ == null) {
          graph_ = new global::ONNX.GraphProto();
        }
        Graph.MergeFrom(other.Graph);
      }
      metadataProps_.Add(other.metadataProps_);
      externalModels_.Add(other.externalModels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            IrVersion = input.ReadInt64();
            break;
          }
          case 18: {
            ProducerName = input.ReadString();
            break;
          }
          case 26: {
            ProducerVersion = input.ReadString();
            break;
          }
          case 34: {
            Domain = input.ReadString();
            break;
          }
          case 40: {
            ModelVersion = input.ReadInt64();
            break;
          }
          case 50: {
            DocString = input.ReadString();
            break;
          }
          case 58: {
            if (graph_ == null) {
              graph_ = new global::ONNX.GraphProto();
            }
            input.ReadMessage(graph_);
            break;
          }
          case 66: {
            opsetImport_.AddEntriesFrom(input, _repeated_opsetImport_codec);
            break;
          }
          case 114: {
            metadataProps_.AddEntriesFrom(input, _repeated_metadataProps_codec);
            break;
          }
          case 122: {
            externalModels_.AddEntriesFrom(input, _repeated_externalModels_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// StringStringEntryProto follows the pattern for cross-proto-version maps.
  /// See https://developers.google.com/protocol-buffers/docs/proto3#maps
  /// </summary>
  public sealed partial class StringStringEntryProto : pb::IMessage<StringStringEntryProto> {
    private static readonly pb::MessageParser<StringStringEntryProto> _parser = new pb::MessageParser<StringStringEntryProto>(() => new StringStringEntryProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StringStringEntryProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StringStringEntryProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StringStringEntryProto(StringStringEntryProto other) : this() {
      key_ = other.key_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StringStringEntryProto Clone() {
      return new StringStringEntryProto(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private string key_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Key {
      get { return key_; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private string value_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StringStringEntryProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StringStringEntryProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Key.Length != 0) hash ^= Key.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Key.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Key.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StringStringEntryProto other) {
      if (other == null) {
        return;
      }
      if (other.Key.Length != 0) {
        Key = other.Key;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// GraphProto defines a parameterized series of nodes to form a directed acyclic graph.
  /// This is the equivalent of the "network" and "graph" in many deep learning
  /// frameworks.
  /// </summary>
  public sealed partial class GraphProto : pb::IMessage<GraphProto> {
    private static readonly pb::MessageParser<GraphProto> _parser = new pb::MessageParser<GraphProto>(() => new GraphProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GraphProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraphProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraphProto(GraphProto other) : this() {
      node_ = other.node_.Clone();
      name_ = other.name_;
      initializer_ = other.initializer_.Clone();
      docString_ = other.docString_;
      input_ = other.input_.Clone();
      output_ = other.output_.Clone();
      valueInfo_ = other.valueInfo_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraphProto Clone() {
      return new GraphProto(this);
    }

    /// <summary>Field number for the "node" field.</summary>
    public const int NodeFieldNumber = 1;
    private static readonly pb::FieldCodec<global::ONNX.NodeProto> _repeated_node_codec
        = pb::FieldCodec.ForMessage(10, global::ONNX.NodeProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.NodeProto> node_ = new pbc::RepeatedField<global::ONNX.NodeProto>();
    /// <summary>
    /// The nodes in the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.NodeProto> Node {
      get { return node_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// The name of the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "initializer" field.</summary>
    public const int InitializerFieldNumber = 5;
    private static readonly pb::FieldCodec<global::ONNX.TensorProto> _repeated_initializer_codec
        = pb::FieldCodec.ForMessage(42, global::ONNX.TensorProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.TensorProto> initializer_ = new pbc::RepeatedField<global::ONNX.TensorProto>();
    /// <summary>
    /// A list of named tensor values (constants), used to specify default
    /// values for some of the inputs of the graph.
    /// Each TensorProto entry must have a distinct name (within the list) that
    /// also appears in the input list.
    /// In an evaluation, the default value specified here is used if and only if
    /// user specifies no value for the corresponding input parameter.
    /// May be used to pass serialized parameters for networks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.TensorProto> Initializer {
      get { return initializer_; }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 10;
    private string docString_ = "";
    /// <summary>
    /// A human-readable documentation for this graph. Markdown is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "input" field.</summary>
    public const int InputFieldNumber = 11;
    private static readonly pb::FieldCodec<global::ONNX.ValueInfoProto> _repeated_input_codec
        = pb::FieldCodec.ForMessage(90, global::ONNX.ValueInfoProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.ValueInfoProto> input_ = new pbc::RepeatedField<global::ONNX.ValueInfoProto>();
    /// <summary>
    /// The inputs and outputs of the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.ValueInfoProto> Input {
      get { return input_; }
    }

    /// <summary>Field number for the "output" field.</summary>
    public const int OutputFieldNumber = 12;
    private static readonly pb::FieldCodec<global::ONNX.ValueInfoProto> _repeated_output_codec
        = pb::FieldCodec.ForMessage(98, global::ONNX.ValueInfoProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.ValueInfoProto> output_ = new pbc::RepeatedField<global::ONNX.ValueInfoProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.ValueInfoProto> Output {
      get { return output_; }
    }

    /// <summary>Field number for the "value_info" field.</summary>
    public const int ValueInfoFieldNumber = 13;
    private static readonly pb::FieldCodec<global::ONNX.ValueInfoProto> _repeated_valueInfo_codec
        = pb::FieldCodec.ForMessage(106, global::ONNX.ValueInfoProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.ValueInfoProto> valueInfo_ = new pbc::RepeatedField<global::ONNX.ValueInfoProto>();
    /// <summary>
    /// Information for the values in the graph. The ValueInfoProto.name's
    /// must be distinct. It is optional for a value to appear in value_info list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.ValueInfoProto> ValueInfo {
      get { return valueInfo_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GraphProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GraphProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!node_.Equals(other.node_)) return false;
      if (Name != other.Name) return false;
      if(!initializer_.Equals(other.initializer_)) return false;
      if (DocString != other.DocString) return false;
      if(!input_.Equals(other.input_)) return false;
      if(!output_.Equals(other.output_)) return false;
      if(!valueInfo_.Equals(other.valueInfo_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= node_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= initializer_.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      hash ^= input_.GetHashCode();
      hash ^= output_.GetHashCode();
      hash ^= valueInfo_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      node_.WriteTo(output, _repeated_node_codec);
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      initializer_.WriteTo(output, _repeated_initializer_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(DocString);
      }
      input_.WriteTo(output, _repeated_input_codec);
      output_.WriteTo(output, _repeated_output_codec);
      valueInfo_.WriteTo(output, _repeated_valueInfo_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += node_.CalculateSize(_repeated_node_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += initializer_.CalculateSize(_repeated_initializer_codec);
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      size += input_.CalculateSize(_repeated_input_codec);
      size += output_.CalculateSize(_repeated_output_codec);
      size += valueInfo_.CalculateSize(_repeated_valueInfo_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GraphProto other) {
      if (other == null) {
        return;
      }
      node_.Add(other.node_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      initializer_.Add(other.initializer_);
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      input_.Add(other.input_);
      output_.Add(other.output_);
      valueInfo_.Add(other.valueInfo_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            node_.AddEntriesFrom(input, _repeated_node_codec);
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 42: {
            initializer_.AddEntriesFrom(input, _repeated_initializer_codec);
            break;
          }
          case 82: {
            DocString = input.ReadString();
            break;
          }
          case 90: {
            input_.AddEntriesFrom(input, _repeated_input_codec);
            break;
          }
          case 98: {
            output_.AddEntriesFrom(input, _repeated_output_codec);
            break;
          }
          case 106: {
            valueInfo_.AddEntriesFrom(input, _repeated_valueInfo_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A message defined to store a tensor in its serialized format.
  /// </summary>
  public sealed partial class TensorProto : pb::IMessage<TensorProto> {
    private static readonly pb::MessageParser<TensorProto> _parser = new pb::MessageParser<TensorProto>(() => new TensorProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TensorProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorProto(TensorProto other) : this() {
      dims_ = other.dims_.Clone();
      dataType_ = other.dataType_;
      Segment = other.segment_ != null ? other.Segment.Clone() : null;
      floatData_ = other.floatData_.Clone();
      int32Data_ = other.int32Data_.Clone();
      stringData_ = other.stringData_.Clone();
      int64Data_ = other.int64Data_.Clone();
      name_ = other.name_;
      docString_ = other.docString_;
      rawData_ = other.rawData_;
      doubleData_ = other.doubleData_.Clone();
      uint64Data_ = other.uint64Data_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorProto Clone() {
      return new TensorProto(this);
    }

    /// <summary>Field number for the "dims" field.</summary>
    public const int DimsFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_dims_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The shape of the tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Dims {
      get { return dims_; }
    }

    /// <summary>Field number for the "data_type" field.</summary>
    public const int DataTypeFieldNumber = 2;
    private global::ONNX.TensorProto.Types.DataType dataType_ = 0;
    /// <summary>
    /// The data type of the tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TensorProto.Types.DataType DataType {
      get { return dataType_; }
      set {
        dataType_ = value;
      }
    }

    /// <summary>Field number for the "segment" field.</summary>
    public const int SegmentFieldNumber = 3;
    private global::ONNX.TensorProto.Types.Segment segment_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TensorProto.Types.Segment Segment {
      get { return segment_; }
      set {
        segment_ = value;
      }
    }

    /// <summary>Field number for the "float_data" field.</summary>
    public const int FloatDataFieldNumber = 4;
    private static readonly pb::FieldCodec<float> _repeated_floatData_codec
        = pb::FieldCodec.ForFloat(34);
    private readonly pbc::RepeatedField<float> floatData_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// For float and complex64 values
    /// Complex64 tensors are encoded as a single array of floats,
    /// with the real components appearing in odd numbered positions,
    /// and the corresponding imaginary component apparing in the
    /// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
    /// is encoded as [1.0, 2.0 ,3.0 ,4.0]
    /// When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> FloatData {
      get { return floatData_; }
    }

    /// <summary>Field number for the "int32_data" field.</summary>
    public const int Int32DataFieldNumber = 5;
    private static readonly pb::FieldCodec<int> _repeated_int32Data_codec
        = pb::FieldCodec.ForInt32(42);
    private readonly pbc::RepeatedField<int> int32Data_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// For int32, uint8, int8, uint16, int16, bool, and float16 values
    /// float16 values must be bit-wise converted to an uint16_t prior
    /// to writing to the buffer.
    /// When this field is present, the data_type field MUST be
    /// INT32, INT16, INT8, UINT16, INT8, BOOL, or FLOAT32
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> Int32Data {
      get { return int32Data_; }
    }

    /// <summary>Field number for the "string_data" field.</summary>
    public const int StringDataFieldNumber = 6;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_stringData_codec
        = pb::FieldCodec.ForBytes(50);
    private readonly pbc::RepeatedField<pb::ByteString> stringData_ = new pbc::RepeatedField<pb::ByteString>();
    /// <summary>
    /// For strings.
    /// Each element of string_data is a UTF-8 encoded Unicode
    /// string. No trailing null, no leading BOM. The protobuf "string"
    /// scalar type is not used to match ML community conventions.
    /// When this field is present, the data_type field MUST be STRING
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<pb::ByteString> StringData {
      get { return stringData_; }
    }

    /// <summary>Field number for the "int64_data" field.</summary>
    public const int Int64DataFieldNumber = 7;
    private static readonly pb::FieldCodec<long> _repeated_int64Data_codec
        = pb::FieldCodec.ForInt64(58);
    private readonly pbc::RepeatedField<long> int64Data_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// For int64.
    /// When this field is present, the data_type field MUST be INT64
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Int64Data {
      get { return int64Data_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 8;
    private string name_ = "";
    /// <summary>
    /// Optionally, a name for the tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 12;
    private string docString_ = "";
    /// <summary>
    /// A human-readable documentation for this tensor. Markdown is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "raw_data" field.</summary>
    public const int RawDataFieldNumber = 9;
    private pb::ByteString rawData_ = pb::ByteString.Empty;
    /// <summary>
    /// Serializations can either use one of the fields above, or use this
    /// raw bytes field. The only exception is the string case, where one is
    /// required to store the content in the repeated bytes string_data field.
    ///
    /// When this raw_data field is used to store tensor value, elements MUST
    /// be stored in as fixed-width, little-endian order.
    /// Floating-point data types MUST be stored in IEEE 754 format.
    /// Complex64 elements must be written as two consecutive FLOAT values, real component first.
    /// Complex128 elements must be written as two consecutive DOUBLE values, real component first.
    /// Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
    ///
    /// Note: the advantage of specific field rather than the raw_data field is
    /// that in some cases (e.g. int data), protobuf does a better packing via
    /// variable length storage, and may lead to smaller binary footprint.
    /// When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString RawData {
      get { return rawData_; }
      set {
        rawData_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "double_data" field.</summary>
    public const int DoubleDataFieldNumber = 10;
    private static readonly pb::FieldCodec<double> _repeated_doubleData_codec
        = pb::FieldCodec.ForDouble(82);
    private readonly pbc::RepeatedField<double> doubleData_ = new pbc::RepeatedField<double>();
    /// <summary>
    /// For double
    /// Complex64 tensors are encoded as a single array of doubles,
    /// with the real components appearing in odd numbered positions,
    /// and the corresponding imaginary component apparing in the
    /// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
    /// is encoded as [1.0, 2.0 ,3.0 ,4.0]
    /// When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<double> DoubleData {
      get { return doubleData_; }
    }

    /// <summary>Field number for the "uint64_data" field.</summary>
    public const int Uint64DataFieldNumber = 11;
    private static readonly pb::FieldCodec<ulong> _repeated_uint64Data_codec
        = pb::FieldCodec.ForUInt64(90);
    private readonly pbc::RepeatedField<ulong> uint64Data_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    /// For uint64 and uint32 values
    /// When this field is present, the data_type field MUST be
    /// UINT32 or UINT64
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<ulong> Uint64Data {
      get { return uint64Data_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TensorProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TensorProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dims_.Equals(other.dims_)) return false;
      if (DataType != other.DataType) return false;
      if (!object.Equals(Segment, other.Segment)) return false;
      if(!floatData_.Equals(other.floatData_)) return false;
      if(!int32Data_.Equals(other.int32Data_)) return false;
      if(!stringData_.Equals(other.stringData_)) return false;
      if(!int64Data_.Equals(other.int64Data_)) return false;
      if (Name != other.Name) return false;
      if (DocString != other.DocString) return false;
      if (RawData != other.RawData) return false;
      if(!doubleData_.Equals(other.doubleData_)) return false;
      if(!uint64Data_.Equals(other.uint64Data_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dims_.GetHashCode();
      if (DataType != 0) hash ^= DataType.GetHashCode();
      if (segment_ != null) hash ^= Segment.GetHashCode();
      hash ^= floatData_.GetHashCode();
      hash ^= int32Data_.GetHashCode();
      hash ^= stringData_.GetHashCode();
      hash ^= int64Data_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      if (RawData.Length != 0) hash ^= RawData.GetHashCode();
      hash ^= doubleData_.GetHashCode();
      hash ^= uint64Data_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      dims_.WriteTo(output, _repeated_dims_codec);
      if (DataType != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataType);
      }
      if (segment_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Segment);
      }
      floatData_.WriteTo(output, _repeated_floatData_codec);
      int32Data_.WriteTo(output, _repeated_int32Data_codec);
      stringData_.WriteTo(output, _repeated_stringData_codec);
      int64Data_.WriteTo(output, _repeated_int64Data_codec);
      if (Name.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Name);
      }
      if (RawData.Length != 0) {
        output.WriteRawTag(74);
        output.WriteBytes(RawData);
      }
      doubleData_.WriteTo(output, _repeated_doubleData_codec);
      uint64Data_.WriteTo(output, _repeated_uint64Data_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(98);
        output.WriteString(DocString);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += dims_.CalculateSize(_repeated_dims_codec);
      if (DataType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
      }
      if (segment_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Segment);
      }
      size += floatData_.CalculateSize(_repeated_floatData_codec);
      size += int32Data_.CalculateSize(_repeated_int32Data_codec);
      size += stringData_.CalculateSize(_repeated_stringData_codec);
      size += int64Data_.CalculateSize(_repeated_int64Data_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      if (RawData.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RawData);
      }
      size += doubleData_.CalculateSize(_repeated_doubleData_codec);
      size += uint64Data_.CalculateSize(_repeated_uint64Data_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TensorProto other) {
      if (other == null) {
        return;
      }
      dims_.Add(other.dims_);
      if (other.DataType != 0) {
        DataType = other.DataType;
      }
      if (other.segment_ != null) {
        if (segment_ == null) {
          segment_ = new global::ONNX.TensorProto.Types.Segment();
        }
        Segment.MergeFrom(other.Segment);
      }
      floatData_.Add(other.floatData_);
      int32Data_.Add(other.int32Data_);
      stringData_.Add(other.stringData_);
      int64Data_.Add(other.int64Data_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      if (other.RawData.Length != 0) {
        RawData = other.RawData;
      }
      doubleData_.Add(other.doubleData_);
      uint64Data_.Add(other.uint64Data_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            dims_.AddEntriesFrom(input, _repeated_dims_codec);
            break;
          }
          case 16: {
            dataType_ = (global::ONNX.TensorProto.Types.DataType) input.ReadEnum();
            break;
          }
          case 26: {
            if (segment_ == null) {
              segment_ = new global::ONNX.TensorProto.Types.Segment();
            }
            input.ReadMessage(segment_);
            break;
          }
          case 34:
          case 37: {
            floatData_.AddEntriesFrom(input, _repeated_floatData_codec);
            break;
          }
          case 42:
          case 40: {
            int32Data_.AddEntriesFrom(input, _repeated_int32Data_codec);
            break;
          }
          case 50: {
            stringData_.AddEntriesFrom(input, _repeated_stringData_codec);
            break;
          }
          case 58:
          case 56: {
            int64Data_.AddEntriesFrom(input, _repeated_int64Data_codec);
            break;
          }
          case 66: {
            Name = input.ReadString();
            break;
          }
          case 74: {
            RawData = input.ReadBytes();
            break;
          }
          case 82:
          case 81: {
            doubleData_.AddEntriesFrom(input, _repeated_doubleData_codec);
            break;
          }
          case 90:
          case 88: {
            uint64Data_.AddEntriesFrom(input, _repeated_uint64Data_codec);
            break;
          }
          case 98: {
            DocString = input.ReadString();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TensorProto message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum DataType {
        [pbr::OriginalName("UNDEFINED")] Undefined = 0,
        /// <summary>
        /// Basic types.
        /// </summary>
        [pbr::OriginalName("FLOAT")] Float = 1,
        /// <summary>
        /// uint8_t
        /// </summary>
        [pbr::OriginalName("UINT8")] Uint8 = 2,
        /// <summary>
        /// int8_t
        /// </summary>
        [pbr::OriginalName("INT8")] Int8 = 3,
        /// <summary>
        /// uint16_t
        /// </summary>
        [pbr::OriginalName("UINT16")] Uint16 = 4,
        /// <summary>
        /// int16_t
        /// </summary>
        [pbr::OriginalName("INT16")] Int16 = 5,
        /// <summary>
        /// int32_t
        /// </summary>
        [pbr::OriginalName("INT32")] Int32 = 6,
        /// <summary>
        /// int64_t
        /// </summary>
        [pbr::OriginalName("INT64")] Int64 = 7,
        /// <summary>
        /// string
        /// </summary>
        [pbr::OriginalName("STRING")] String = 8,
        /// <summary>
        /// bool
        /// </summary>
        [pbr::OriginalName("BOOL")] Bool = 9,
        /// <summary>
        /// Advanced types
        /// </summary>
        [pbr::OriginalName("FLOAT16")] Float16 = 10,
        [pbr::OriginalName("DOUBLE")] Double = 11,
        [pbr::OriginalName("UINT32")] Uint32 = 12,
        [pbr::OriginalName("UINT64")] Uint64 = 13,
        /// <summary>
        /// complex with float32 real and imaginary components
        /// </summary>
        [pbr::OriginalName("COMPLEX64")] Complex64 = 14,
        /// <summary>
        /// complex with float64 real and imaginary components
        /// </summary>
        [pbr::OriginalName("COMPLEX128")] Complex128 = 15,
      }

      /// <summary>
      /// For very large tensors, we may want to store them in chunks, in which
      /// case the following fields will specify the segment that is stored in
      /// the current TensorProto.
      /// </summary>
      public sealed partial class Segment : pb::IMessage<Segment> {
        private static readonly pb::MessageParser<Segment> _parser = new pb::MessageParser<Segment>(() => new Segment());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Segment> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TensorProto.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Segment() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Segment(Segment other) : this() {
          begin_ = other.begin_;
          end_ = other.end_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Segment Clone() {
          return new Segment(this);
        }

        /// <summary>Field number for the "begin" field.</summary>
        public const int BeginFieldNumber = 1;
        private long begin_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long Begin {
          get { return begin_; }
          set {
            begin_ = value;
          }
        }

        /// <summary>Field number for the "end" field.</summary>
        public const int EndFieldNumber = 2;
        private long end_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long End {
          get { return end_; }
          set {
            end_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Segment);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Segment other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Begin != other.Begin) return false;
          if (End != other.End) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Begin != 0L) hash ^= Begin.GetHashCode();
          if (End != 0L) hash ^= End.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Begin != 0L) {
            output.WriteRawTag(8);
            output.WriteInt64(Begin);
          }
          if (End != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(End);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Begin != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(Begin);
          }
          if (End != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(End);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Segment other) {
          if (other == null) {
            return;
          }
          if (other.Begin != 0L) {
            Begin = other.Begin;
          }
          if (other.End != 0L) {
            End = other.End;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Begin = input.ReadInt64();
                break;
              }
              case 16: {
                End = input.ReadInt64();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Defines a tensor shape. A dimension can be either an integer value
  /// or a symbolic variable. A symbolic variable represents an unknown
  /// dimension.
  /// </summary>
  public sealed partial class TensorShapeProto : pb::IMessage<TensorShapeProto> {
    private static readonly pb::MessageParser<TensorShapeProto> _parser = new pb::MessageParser<TensorShapeProto>(() => new TensorShapeProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TensorShapeProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorShapeProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorShapeProto(TensorShapeProto other) : this() {
      dim_ = other.dim_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorShapeProto Clone() {
      return new TensorShapeProto(this);
    }

    /// <summary>Field number for the "dim" field.</summary>
    public const int DimFieldNumber = 1;
    private static readonly pb::FieldCodec<global::ONNX.TensorShapeProto.Types.Dimension> _repeated_dim_codec
        = pb::FieldCodec.ForMessage(10, global::ONNX.TensorShapeProto.Types.Dimension.Parser);
    private readonly pbc::RepeatedField<global::ONNX.TensorShapeProto.Types.Dimension> dim_ = new pbc::RepeatedField<global::ONNX.TensorShapeProto.Types.Dimension>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.TensorShapeProto.Types.Dimension> Dim {
      get { return dim_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TensorShapeProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TensorShapeProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dim_.Equals(other.dim_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dim_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      dim_.WriteTo(output, _repeated_dim_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += dim_.CalculateSize(_repeated_dim_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TensorShapeProto other) {
      if (other == null) {
        return;
      }
      dim_.Add(other.dim_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            dim_.AddEntriesFrom(input, _repeated_dim_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TensorShapeProto message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Dimension : pb::IMessage<Dimension> {
        private static readonly pb::MessageParser<Dimension> _parser = new pb::MessageParser<Dimension>(() => new Dimension());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Dimension> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TensorShapeProto.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Dimension() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Dimension(Dimension other) : this() {
          denotation_ = other.denotation_;
          switch (other.ValueCase) {
            case ValueOneofCase.DimValue:
              DimValue = other.DimValue;
              break;
            case ValueOneofCase.DimParam:
              DimParam = other.DimParam;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Dimension Clone() {
          return new Dimension(this);
        }

        /// <summary>Field number for the "dim_value" field.</summary>
        public const int DimValueFieldNumber = 1;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long DimValue {
          get { return valueCase_ == ValueOneofCase.DimValue ? (long) value_ : 0L; }
          set {
            value_ = value;
            valueCase_ = ValueOneofCase.DimValue;
          }
        }

        /// <summary>Field number for the "dim_param" field.</summary>
        public const int DimParamFieldNumber = 2;
        /// <summary>
        /// namespace Shape
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string DimParam {
          get { return valueCase_ == ValueOneofCase.DimParam ? (string) value_ : ""; }
          set {
            value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            valueCase_ = ValueOneofCase.DimParam;
          }
        }

        /// <summary>Field number for the "denotation" field.</summary>
        public const int DenotationFieldNumber = 3;
        private string denotation_ = "";
        /// <summary>
        /// Standard denotation can optionally be used to denote tensor
        /// dimensions with standard semantic descriptions to ensure
        /// that operations are applied to the correct axis of a tensor.
        /// Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
        /// for pre-defined dimension denotations.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Denotation {
          get { return denotation_; }
          set {
            denotation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        private object value_;
        /// <summary>Enum of possible cases for the "value" oneof.</summary>
        public enum ValueOneofCase {
          None = 0,
          DimValue = 1,
          DimParam = 2,
        }
        private ValueOneofCase valueCase_ = ValueOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ValueOneofCase ValueCase {
          get { return valueCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearValue() {
          valueCase_ = ValueOneofCase.None;
          value_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Dimension);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Dimension other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DimValue != other.DimValue) return false;
          if (DimParam != other.DimParam) return false;
          if (Denotation != other.Denotation) return false;
          if (ValueCase != other.ValueCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (valueCase_ == ValueOneofCase.DimValue) hash ^= DimValue.GetHashCode();
          if (valueCase_ == ValueOneofCase.DimParam) hash ^= DimParam.GetHashCode();
          if (Denotation.Length != 0) hash ^= Denotation.GetHashCode();
          hash ^= (int) valueCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (valueCase_ == ValueOneofCase.DimValue) {
            output.WriteRawTag(8);
            output.WriteInt64(DimValue);
          }
          if (valueCase_ == ValueOneofCase.DimParam) {
            output.WriteRawTag(18);
            output.WriteString(DimParam);
          }
          if (Denotation.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(Denotation);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (valueCase_ == ValueOneofCase.DimValue) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(DimValue);
          }
          if (valueCase_ == ValueOneofCase.DimParam) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DimParam);
          }
          if (Denotation.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Denotation);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Dimension other) {
          if (other == null) {
            return;
          }
          if (other.Denotation.Length != 0) {
            Denotation = other.Denotation;
          }
          switch (other.ValueCase) {
            case ValueOneofCase.DimValue:
              DimValue = other.DimValue;
              break;
            case ValueOneofCase.DimParam:
              DimParam = other.DimParam;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                DimValue = input.ReadInt64();
                break;
              }
              case 18: {
                DimParam = input.ReadString();
                break;
              }
              case 26: {
                Denotation = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Define the types.
  /// </summary>
  public sealed partial class TypeProto : pb::IMessage<TypeProto> {
    private static readonly pb::MessageParser<TypeProto> _parser = new pb::MessageParser<TypeProto>(() => new TypeProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TypeProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeProto(TypeProto other) : this() {
      denotation_ = other.denotation_;
      switch (other.ValueCase) {
        case ValueOneofCase.TensorType:
          TensorType = other.TensorType.Clone();
          break;
        case ValueOneofCase.SequenceType:
          SequenceType = other.SequenceType.Clone();
          break;
        case ValueOneofCase.MapType:
          MapType = other.MapType.Clone();
          break;
        case ValueOneofCase.TupleType:
          TupleType = other.TupleType.Clone();
          break;
        case ValueOneofCase.OpaqueType:
          OpaqueType = other.OpaqueType.Clone();
          break;
        case ValueOneofCase.SparseType:
          SparseType = other.SparseType.Clone();
          break;
        case ValueOneofCase.RecordType:
          RecordType = other.RecordType.Clone();
          break;
        case ValueOneofCase.NullableType:
          NullableType = other.NullableType.Clone();
          break;
        case ValueOneofCase.ScalarType:
          ScalarType = other.ScalarType.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeProto Clone() {
      return new TypeProto(this);
    }

    /// <summary>Field number for the "tensor_type" field.</summary>
    public const int TensorTypeFieldNumber = 1;
    /// <summary>
    /// The type of a tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TypeProto.Types.Tensor TensorType {
      get { return valueCase_ == ValueOneofCase.TensorType ? (global::ONNX.TypeProto.Types.Tensor) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.TensorType;
      }
    }

    /// <summary>Field number for the "sequence_type" field.</summary>
    public const int SequenceTypeFieldNumber = 4;
    /// <summary>
    /// The type of a sequence.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TypeProto.Types.Sequence SequenceType {
      get { return valueCase_ == ValueOneofCase.SequenceType ? (global::ONNX.TypeProto.Types.Sequence) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.SequenceType;
      }
    }

    /// <summary>Field number for the "map_type" field.</summary>
    public const int MapTypeFieldNumber = 5;
    /// <summary>
    /// The type of a map.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TypeProto.Types.Map MapType {
      get { return valueCase_ == ValueOneofCase.MapType ? (global::ONNX.TypeProto.Types.Map) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.MapType;
      }
    }

    /// <summary>Field number for the "tuple_type" field.</summary>
    public const int TupleTypeFieldNumber = 7;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TypeProto.Types.Tuple TupleType {
      get { return valueCase_ == ValueOneofCase.TupleType ? (global::ONNX.TypeProto.Types.Tuple) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.TupleType;
      }
    }

    /// <summary>Field number for the "opaque_type" field.</summary>
    public const int OpaqueTypeFieldNumber = 8;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TypeProto.Types.Opaque OpaqueType {
      get { return valueCase_ == ValueOneofCase.OpaqueType ? (global::ONNX.TypeProto.Types.Opaque) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.OpaqueType;
      }
    }

    /// <summary>Field number for the "sparse_type" field.</summary>
    public const int SparseTypeFieldNumber = 9;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TypeProto.Types.SparseTensor SparseType {
      get { return valueCase_ == ValueOneofCase.SparseType ? (global::ONNX.TypeProto.Types.SparseTensor) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.SparseType;
      }
    }

    /// <summary>Field number for the "record_type" field.</summary>
    public const int RecordTypeFieldNumber = 10;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TypeProto.Types.Record RecordType {
      get { return valueCase_ == ValueOneofCase.RecordType ? (global::ONNX.TypeProto.Types.Record) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.RecordType;
      }
    }

    /// <summary>Field number for the "nullable_type" field.</summary>
    public const int NullableTypeFieldNumber = 11;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TypeProto.Types.Nullable NullableType {
      get { return valueCase_ == ValueOneofCase.NullableType ? (global::ONNX.TypeProto.Types.Nullable) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.NullableType;
      }
    }

    /// <summary>Field number for the "scalar_type" field.</summary>
    public const int ScalarTypeFieldNumber = 12;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TypeProto.Types.Scalar ScalarType {
      get { return valueCase_ == ValueOneofCase.ScalarType ? (global::ONNX.TypeProto.Types.Scalar) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.ScalarType;
      }
    }

    /// <summary>Field number for the "denotation" field.</summary>
    public const int DenotationFieldNumber = 6;
    private string denotation_ = "";
    /// <summary>
    /// An optional denotation can be used to denote the whole 
    /// type with a standard semantic description as to what is 
    /// stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
    /// for pre-defined type denotations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Denotation {
      get { return denotation_; }
      set {
        denotation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private object value_;
    /// <summary>Enum of possible cases for the "value" oneof.</summary>
    public enum ValueOneofCase {
      None = 0,
      TensorType = 1,
      SequenceType = 4,
      MapType = 5,
      TupleType = 7,
      OpaqueType = 8,
      SparseType = 9,
      RecordType = 10,
      NullableType = 11,
      ScalarType = 12,
    }
    private ValueOneofCase valueCase_ = ValueOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueOneofCase ValueCase {
      get { return valueCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValue() {
      valueCase_ = ValueOneofCase.None;
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TypeProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TypeProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TensorType, other.TensorType)) return false;
      if (!object.Equals(SequenceType, other.SequenceType)) return false;
      if (!object.Equals(MapType, other.MapType)) return false;
      if (!object.Equals(TupleType, other.TupleType)) return false;
      if (!object.Equals(OpaqueType, other.OpaqueType)) return false;
      if (!object.Equals(SparseType, other.SparseType)) return false;
      if (!object.Equals(RecordType, other.RecordType)) return false;
      if (!object.Equals(NullableType, other.NullableType)) return false;
      if (!object.Equals(ScalarType, other.ScalarType)) return false;
      if (Denotation != other.Denotation) return false;
      if (ValueCase != other.ValueCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (valueCase_ == ValueOneofCase.TensorType) hash ^= TensorType.GetHashCode();
      if (valueCase_ == ValueOneofCase.SequenceType) hash ^= SequenceType.GetHashCode();
      if (valueCase_ == ValueOneofCase.MapType) hash ^= MapType.GetHashCode();
      if (valueCase_ == ValueOneofCase.TupleType) hash ^= TupleType.GetHashCode();
      if (valueCase_ == ValueOneofCase.OpaqueType) hash ^= OpaqueType.GetHashCode();
      if (valueCase_ == ValueOneofCase.SparseType) hash ^= SparseType.GetHashCode();
      if (valueCase_ == ValueOneofCase.RecordType) hash ^= RecordType.GetHashCode();
      if (valueCase_ == ValueOneofCase.NullableType) hash ^= NullableType.GetHashCode();
      if (valueCase_ == ValueOneofCase.ScalarType) hash ^= ScalarType.GetHashCode();
      if (Denotation.Length != 0) hash ^= Denotation.GetHashCode();
      hash ^= (int) valueCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (valueCase_ == ValueOneofCase.TensorType) {
        output.WriteRawTag(10);
        output.WriteMessage(TensorType);
      }
      if (valueCase_ == ValueOneofCase.SequenceType) {
        output.WriteRawTag(34);
        output.WriteMessage(SequenceType);
      }
      if (valueCase_ == ValueOneofCase.MapType) {
        output.WriteRawTag(42);
        output.WriteMessage(MapType);
      }
      if (Denotation.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Denotation);
      }
      if (valueCase_ == ValueOneofCase.TupleType) {
        output.WriteRawTag(58);
        output.WriteMessage(TupleType);
      }
      if (valueCase_ == ValueOneofCase.OpaqueType) {
        output.WriteRawTag(66);
        output.WriteMessage(OpaqueType);
      }
      if (valueCase_ == ValueOneofCase.SparseType) {
        output.WriteRawTag(74);
        output.WriteMessage(SparseType);
      }
      if (valueCase_ == ValueOneofCase.RecordType) {
        output.WriteRawTag(82);
        output.WriteMessage(RecordType);
      }
      if (valueCase_ == ValueOneofCase.NullableType) {
        output.WriteRawTag(90);
        output.WriteMessage(NullableType);
      }
      if (valueCase_ == ValueOneofCase.ScalarType) {
        output.WriteRawTag(98);
        output.WriteMessage(ScalarType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (valueCase_ == ValueOneofCase.TensorType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TensorType);
      }
      if (valueCase_ == ValueOneofCase.SequenceType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SequenceType);
      }
      if (valueCase_ == ValueOneofCase.MapType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MapType);
      }
      if (valueCase_ == ValueOneofCase.TupleType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TupleType);
      }
      if (valueCase_ == ValueOneofCase.OpaqueType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OpaqueType);
      }
      if (valueCase_ == ValueOneofCase.SparseType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SparseType);
      }
      if (valueCase_ == ValueOneofCase.RecordType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RecordType);
      }
      if (valueCase_ == ValueOneofCase.NullableType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NullableType);
      }
      if (valueCase_ == ValueOneofCase.ScalarType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScalarType);
      }
      if (Denotation.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Denotation);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TypeProto other) {
      if (other == null) {
        return;
      }
      if (other.Denotation.Length != 0) {
        Denotation = other.Denotation;
      }
      switch (other.ValueCase) {
        case ValueOneofCase.TensorType:
          if (TensorType == null) {
            TensorType = new global::ONNX.TypeProto.Types.Tensor();
          }
          TensorType.MergeFrom(other.TensorType);
          break;
        case ValueOneofCase.SequenceType:
          if (SequenceType == null) {
            SequenceType = new global::ONNX.TypeProto.Types.Sequence();
          }
          SequenceType.MergeFrom(other.SequenceType);
          break;
        case ValueOneofCase.MapType:
          if (MapType == null) {
            MapType = new global::ONNX.TypeProto.Types.Map();
          }
          MapType.MergeFrom(other.MapType);
          break;
        case ValueOneofCase.TupleType:
          if (TupleType == null) {
            TupleType = new global::ONNX.TypeProto.Types.Tuple();
          }
          TupleType.MergeFrom(other.TupleType);
          break;
        case ValueOneofCase.OpaqueType:
          if (OpaqueType == null) {
            OpaqueType = new global::ONNX.TypeProto.Types.Opaque();
          }
          OpaqueType.MergeFrom(other.OpaqueType);
          break;
        case ValueOneofCase.SparseType:
          if (SparseType == null) {
            SparseType = new global::ONNX.TypeProto.Types.SparseTensor();
          }
          SparseType.MergeFrom(other.SparseType);
          break;
        case ValueOneofCase.RecordType:
          if (RecordType == null) {
            RecordType = new global::ONNX.TypeProto.Types.Record();
          }
          RecordType.MergeFrom(other.RecordType);
          break;
        case ValueOneofCase.NullableType:
          if (NullableType == null) {
            NullableType = new global::ONNX.TypeProto.Types.Nullable();
          }
          NullableType.MergeFrom(other.NullableType);
          break;
        case ValueOneofCase.ScalarType:
          if (ScalarType == null) {
            ScalarType = new global::ONNX.TypeProto.Types.Scalar();
          }
          ScalarType.MergeFrom(other.ScalarType);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::ONNX.TypeProto.Types.Tensor subBuilder = new global::ONNX.TypeProto.Types.Tensor();
            if (valueCase_ == ValueOneofCase.TensorType) {
              subBuilder.MergeFrom(TensorType);
            }
            input.ReadMessage(subBuilder);
            TensorType = subBuilder;
            break;
          }
          case 34: {
            global::ONNX.TypeProto.Types.Sequence subBuilder = new global::ONNX.TypeProto.Types.Sequence();
            if (valueCase_ == ValueOneofCase.SequenceType) {
              subBuilder.MergeFrom(SequenceType);
            }
            input.ReadMessage(subBuilder);
            SequenceType = subBuilder;
            break;
          }
          case 42: {
            global::ONNX.TypeProto.Types.Map subBuilder = new global::ONNX.TypeProto.Types.Map();
            if (valueCase_ == ValueOneofCase.MapType) {
              subBuilder.MergeFrom(MapType);
            }
            input.ReadMessage(subBuilder);
            MapType = subBuilder;
            break;
          }
          case 50: {
            Denotation = input.ReadString();
            break;
          }
          case 58: {
            global::ONNX.TypeProto.Types.Tuple subBuilder = new global::ONNX.TypeProto.Types.Tuple();
            if (valueCase_ == ValueOneofCase.TupleType) {
              subBuilder.MergeFrom(TupleType);
            }
            input.ReadMessage(subBuilder);
            TupleType = subBuilder;
            break;
          }
          case 66: {
            global::ONNX.TypeProto.Types.Opaque subBuilder = new global::ONNX.TypeProto.Types.Opaque();
            if (valueCase_ == ValueOneofCase.OpaqueType) {
              subBuilder.MergeFrom(OpaqueType);
            }
            input.ReadMessage(subBuilder);
            OpaqueType = subBuilder;
            break;
          }
          case 74: {
            global::ONNX.TypeProto.Types.SparseTensor subBuilder = new global::ONNX.TypeProto.Types.SparseTensor();
            if (valueCase_ == ValueOneofCase.SparseType) {
              subBuilder.MergeFrom(SparseType);
            }
            input.ReadMessage(subBuilder);
            SparseType = subBuilder;
            break;
          }
          case 82: {
            global::ONNX.TypeProto.Types.Record subBuilder = new global::ONNX.TypeProto.Types.Record();
            if (valueCase_ == ValueOneofCase.RecordType) {
              subBuilder.MergeFrom(RecordType);
            }
            input.ReadMessage(subBuilder);
            RecordType = subBuilder;
            break;
          }
          case 90: {
            global::ONNX.TypeProto.Types.Nullable subBuilder = new global::ONNX.TypeProto.Types.Nullable();
            if (valueCase_ == ValueOneofCase.NullableType) {
              subBuilder.MergeFrom(NullableType);
            }
            input.ReadMessage(subBuilder);
            NullableType = subBuilder;
            break;
          }
          case 98: {
            global::ONNX.TypeProto.Types.Scalar subBuilder = new global::ONNX.TypeProto.Types.Scalar();
            if (valueCase_ == ValueOneofCase.ScalarType) {
              subBuilder.MergeFrom(ScalarType);
            }
            input.ReadMessage(subBuilder);
            ScalarType = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TypeProto message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Tensor : pb::IMessage<Tensor> {
        private static readonly pb::MessageParser<Tensor> _parser = new pb::MessageParser<Tensor>(() => new Tensor());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Tensor> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TypeProto.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tensor() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tensor(Tensor other) : this() {
          elemType_ = other.elemType_;
          Shape = other.shape_ != null ? other.Shape.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tensor Clone() {
          return new Tensor(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private global::ONNX.TensorProto.Types.DataType elemType_ = 0;
        /// <summary>
        /// This field MUST NOT have the value of UNDEFINED
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorProto.Types.DataType ElemType {
          get { return elemType_; }
          set {
            elemType_ = value;
          }
        }

        /// <summary>Field number for the "shape" field.</summary>
        public const int ShapeFieldNumber = 2;
        private global::ONNX.TensorShapeProto shape_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorShapeProto Shape {
          get { return shape_; }
          set {
            shape_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Tensor);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Tensor other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ElemType != other.ElemType) return false;
          if (!object.Equals(Shape, other.Shape)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (ElemType != 0) hash ^= ElemType.GetHashCode();
          if (shape_ != null) hash ^= Shape.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (ElemType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) ElemType);
          }
          if (shape_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Shape);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (ElemType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ElemType);
          }
          if (shape_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Shape);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Tensor other) {
          if (other == null) {
            return;
          }
          if (other.ElemType != 0) {
            ElemType = other.ElemType;
          }
          if (other.shape_ != null) {
            if (shape_ == null) {
              shape_ = new global::ONNX.TensorShapeProto();
            }
            Shape.MergeFrom(other.Shape);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                elemType_ = (global::ONNX.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
              case 18: {
                if (shape_ == null) {
                  shape_ = new global::ONNX.TensorShapeProto();
                }
                input.ReadMessage(shape_);
                break;
              }
            }
          }
        }

      }

      public sealed partial class Scalar : pb::IMessage<Scalar> {
        private static readonly pb::MessageParser<Scalar> _parser = new pb::MessageParser<Scalar>(() => new Scalar());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Scalar> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TypeProto.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Scalar() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Scalar(Scalar other) : this() {
          dataType_ = other.dataType_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Scalar Clone() {
          return new Scalar(this);
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 1;
        private global::ONNX.TensorProto.Types.DataType dataType_ = 0;
        /// <summary>
        /// This field MUST NOT have the value of UNDEFINED 
        /// This field MUST be present for this version of the IR. 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorProto.Types.DataType DataType {
          get { return dataType_; }
          set {
            dataType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Scalar);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Scalar other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DataType != other.DataType) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (DataType != 0) hash ^= DataType.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (DataType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) DataType);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (DataType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Scalar other) {
          if (other == null) {
            return;
          }
          if (other.DataType != 0) {
            DataType = other.DataType;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                dataType_ = (global::ONNX.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// repeated T
      /// </summary>
      public sealed partial class Sequence : pb::IMessage<Sequence> {
        private static readonly pb::MessageParser<Sequence> _parser = new pb::MessageParser<Sequence>(() => new Sequence());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Sequence> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TypeProto.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Sequence() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Sequence(Sequence other) : this() {
          ElemType = other.elemType_ != null ? other.ElemType.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Sequence Clone() {
          return new Sequence(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private global::ONNX.TypeProto elemType_;
        /// <summary>
        /// The type and optional shape of each element of the sequence.
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TypeProto ElemType {
          get { return elemType_; }
          set {
            elemType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Sequence);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Sequence other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ElemType, other.ElemType)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (elemType_ != null) hash ^= ElemType.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (elemType_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(ElemType);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (elemType_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ElemType);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Sequence other) {
          if (other == null) {
            return;
          }
          if (other.elemType_ != null) {
            if (elemType_ == null) {
              elemType_ = new global::ONNX.TypeProto();
            }
            ElemType.MergeFrom(other.ElemType);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (elemType_ == null) {
                  elemType_ = new global::ONNX.TypeProto();
                }
                input.ReadMessage(elemType_);
                break;
              }
            }
          }
        }

      }

      public sealed partial class Tuple : pb::IMessage<Tuple> {
        private static readonly pb::MessageParser<Tuple> _parser = new pb::MessageParser<Tuple>(() => new Tuple());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Tuple> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TypeProto.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tuple() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tuple(Tuple other) : this() {
          elemType_ = other.elemType_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tuple Clone() {
          return new Tuple(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private static readonly pb::FieldCodec<global::ONNX.TypeProto> _repeated_elemType_codec
            = pb::FieldCodec.ForMessage(10, global::ONNX.TypeProto.Parser);
        private readonly pbc::RepeatedField<global::ONNX.TypeProto> elemType_ = new pbc::RepeatedField<global::ONNX.TypeProto>();
        /// <summary>
        /// The element types of the tuple. 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::ONNX.TypeProto> ElemType {
          get { return elemType_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Tuple);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Tuple other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!elemType_.Equals(other.elemType_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= elemType_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          elemType_.WriteTo(output, _repeated_elemType_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += elemType_.CalculateSize(_repeated_elemType_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Tuple other) {
          if (other == null) {
            return;
          }
          elemType_.Add(other.elemType_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                elemType_.AddEntriesFrom(input, _repeated_elemType_codec);
                break;
              }
            }
          }
        }

      }

      public sealed partial class Record : pb::IMessage<Record> {
        private static readonly pb::MessageParser<Record> _parser = new pb::MessageParser<Record>(() => new Record());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Record> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TypeProto.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Record() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Record(Record other) : this() {
          domain_ = other.domain_;
          name_ = other.name_;
          fields_ = other.fields_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Record Clone() {
          return new Record(this);
        }

        /// <summary>Field number for the "domain" field.</summary>
        public const int DomainFieldNumber = 1;
        private string domain_ = "";
        /// <summary>
        /// When missing, the domain is the same as the model's. 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Domain {
          get { return domain_; }
          set {
            domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 2;
        private string name_ = "";
        /// <summary>
        /// The name is required for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "fields" field.</summary>
        public const int FieldsFieldNumber = 3;
        private static readonly pb::FieldCodec<global::ONNX.ValueInfoProto> _repeated_fields_codec
            = pb::FieldCodec.ForMessage(26, global::ONNX.ValueInfoProto.Parser);
        private readonly pbc::RepeatedField<global::ONNX.ValueInfoProto> fields_ = new pbc::RepeatedField<global::ONNX.ValueInfoProto>();
        /// <summary>
        /// The name and type of each field is described by a ValueInfoProto. 
        /// The field names must be unique. 
        /// This field MUST be present for this version of the IR. 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::ONNX.ValueInfoProto> Fields {
          get { return fields_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Record);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Record other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Domain != other.Domain) return false;
          if (Name != other.Name) return false;
          if(!fields_.Equals(other.fields_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Domain.Length != 0) hash ^= Domain.GetHashCode();
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          hash ^= fields_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Domain.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Domain);
          }
          if (Name.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Name);
          }
          fields_.WriteTo(output, _repeated_fields_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Domain.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
          }
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          size += fields_.CalculateSize(_repeated_fields_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Record other) {
          if (other == null) {
            return;
          }
          if (other.Domain.Length != 0) {
            Domain = other.Domain;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          fields_.Add(other.fields_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Domain = input.ReadString();
                break;
              }
              case 18: {
                Name = input.ReadString();
                break;
              }
              case 26: {
                fields_.AddEntriesFrom(input, _repeated_fields_codec);
                break;
              }
            }
          }
        }

      }

      public sealed partial class Opaque : pb::IMessage<Opaque> {
        private static readonly pb::MessageParser<Opaque> _parser = new pb::MessageParser<Opaque>(() => new Opaque());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Opaque> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TypeProto.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Opaque() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Opaque(Opaque other) : this() {
          domain_ = other.domain_;
          name_ = other.name_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Opaque Clone() {
          return new Opaque(this);
        }

        /// <summary>Field number for the "domain" field.</summary>
        public const int DomainFieldNumber = 1;
        private string domain_ = "";
        /// <summary>
        /// When missing, the domain is the same as the model's. 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Domain {
          get { return domain_; }
          set {
            domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 2;
        private string name_ = "";
        /// <summary>
        /// The name is optional but significant when provided. 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Opaque);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Opaque other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Domain != other.Domain) return false;
          if (Name != other.Name) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Domain.Length != 0) hash ^= Domain.GetHashCode();
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Domain.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Domain);
          }
          if (Name.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Name);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Domain.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
          }
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Opaque other) {
          if (other == null) {
            return;
          }
          if (other.Domain.Length != 0) {
            Domain = other.Domain;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Domain = input.ReadString();
                break;
              }
              case 18: {
                Name = input.ReadString();
                break;
              }
            }
          }
        }

      }

      public sealed partial class SparseTensor : pb::IMessage<SparseTensor> {
        private static readonly pb::MessageParser<SparseTensor> _parser = new pb::MessageParser<SparseTensor>(() => new SparseTensor());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SparseTensor> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TypeProto.Descriptor.NestedTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensor() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensor(SparseTensor other) : this() {
          elemType_ = other.elemType_;
          Shape = other.shape_ != null ? other.Shape.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensor Clone() {
          return new SparseTensor(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private global::ONNX.TensorProto.Types.DataType elemType_ = 0;
        /// <summary>
        /// This field MUST NOT have the value of UNDEFINED 
        /// This field MUST be present for this version of the IR. 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorProto.Types.DataType ElemType {
          get { return elemType_; }
          set {
            elemType_ = value;
          }
        }

        /// <summary>Field number for the "shape" field.</summary>
        public const int ShapeFieldNumber = 2;
        private global::ONNX.TensorShapeProto shape_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorShapeProto Shape {
          get { return shape_; }
          set {
            shape_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SparseTensor);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SparseTensor other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ElemType != other.ElemType) return false;
          if (!object.Equals(Shape, other.Shape)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (ElemType != 0) hash ^= ElemType.GetHashCode();
          if (shape_ != null) hash ^= Shape.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (ElemType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) ElemType);
          }
          if (shape_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Shape);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (ElemType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ElemType);
          }
          if (shape_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Shape);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SparseTensor other) {
          if (other == null) {
            return;
          }
          if (other.ElemType != 0) {
            ElemType = other.ElemType;
          }
          if (other.shape_ != null) {
            if (shape_ == null) {
              shape_ = new global::ONNX.TensorShapeProto();
            }
            Shape.MergeFrom(other.Shape);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                elemType_ = (global::ONNX.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
              case 18: {
                if (shape_ == null) {
                  shape_ = new global::ONNX.TensorShapeProto();
                }
                input.ReadMessage(shape_);
                break;
              }
            }
          }
        }

      }

      public sealed partial class Nullable : pb::IMessage<Nullable> {
        private static readonly pb::MessageParser<Nullable> _parser = new pb::MessageParser<Nullable>(() => new Nullable());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Nullable> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TypeProto.Descriptor.NestedTypes[7]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Nullable() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Nullable(Nullable other) : this() {
          BaseType = other.baseType_ != null ? other.BaseType.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Nullable Clone() {
          return new Nullable(this);
        }

        /// <summary>Field number for the "base_type" field.</summary>
        public const int BaseTypeFieldNumber = 1;
        private global::ONNX.TypeProto baseType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TypeProto BaseType {
          get { return baseType_; }
          set {
            baseType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Nullable);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Nullable other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(BaseType, other.BaseType)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (baseType_ != null) hash ^= BaseType.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (baseType_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(BaseType);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (baseType_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BaseType);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Nullable other) {
          if (other == null) {
            return;
          }
          if (other.baseType_ != null) {
            if (baseType_ == null) {
              baseType_ = new global::ONNX.TypeProto();
            }
            BaseType.MergeFrom(other.BaseType);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (baseType_ == null) {
                  baseType_ = new global::ONNX.TypeProto();
                }
                input.ReadMessage(baseType_);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// map&lt;K,V>
      /// </summary>
      public sealed partial class Map : pb::IMessage<Map> {
        private static readonly pb::MessageParser<Map> _parser = new pb::MessageParser<Map>(() => new Map());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Map> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ONNX.TypeProto.Descriptor.NestedTypes[8]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Map() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Map(Map other) : this() {
          keyType_ = other.keyType_;
          ValueType = other.valueType_ != null ? other.ValueType.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Map Clone() {
          return new Map(this);
        }

        /// <summary>Field number for the "key_type" field.</summary>
        public const int KeyTypeFieldNumber = 1;
        private global::ONNX.TensorProto.Types.DataType keyType_ = 0;
        /// <summary>
        /// This field MUST be present for this version of the IR.
        /// This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorProto.Types.DataType KeyType {
          get { return keyType_; }
          set {
            keyType_ = value;
          }
        }

        /// <summary>Field number for the "value_type" field.</summary>
        public const int ValueTypeFieldNumber = 2;
        private global::ONNX.TypeProto valueType_;
        /// <summary>
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TypeProto ValueType {
          get { return valueType_; }
          set {
            valueType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Map);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Map other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (KeyType != other.KeyType) return false;
          if (!object.Equals(ValueType, other.ValueType)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (KeyType != 0) hash ^= KeyType.GetHashCode();
          if (valueType_ != null) hash ^= ValueType.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (KeyType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) KeyType);
          }
          if (valueType_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(ValueType);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (KeyType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) KeyType);
          }
          if (valueType_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValueType);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Map other) {
          if (other == null) {
            return;
          }
          if (other.KeyType != 0) {
            KeyType = other.KeyType;
          }
          if (other.valueType_ != null) {
            if (valueType_ == null) {
              valueType_ = new global::ONNX.TypeProto();
            }
            ValueType.MergeFrom(other.ValueType);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                keyType_ = (global::ONNX.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
              case 18: {
                if (valueType_ == null) {
                  valueType_ = new global::ONNX.TypeProto();
                }
                input.ReadMessage(valueType_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// OperatorSets are uniquely identified by a (domain, opset_version) pair.
  /// </summary>
  public sealed partial class OperatorSetIdProto : pb::IMessage<OperatorSetIdProto> {
    private static readonly pb::MessageParser<OperatorSetIdProto> _parser = new pb::MessageParser<OperatorSetIdProto>(() => new OperatorSetIdProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OperatorSetIdProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorSetIdProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorSetIdProto(OperatorSetIdProto other) : this() {
      domain_ = other.domain_;
      version_ = other.version_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorSetIdProto Clone() {
      return new OperatorSetIdProto(this);
    }

    /// <summary>Field number for the "domain" field.</summary>
    public const int DomainFieldNumber = 1;
    private string domain_ = "";
    /// <summary>
    /// The domain of the operator set being identified.
    /// The empty string ("") or absence of this field implies the operator
    /// set that is defined as part of the ONNX specification.
    /// This field MUST be present in this version of the IR when referring to any other operator set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Domain {
      get { return domain_; }
      set {
        domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 2;
    private long version_;
    /// <summary>
    /// The version of the operator set being identified.
    /// This field MUST be present in this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OperatorSetIdProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OperatorSetIdProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Domain != other.Domain) return false;
      if (Version != other.Version) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Domain.Length != 0) hash ^= Domain.GetHashCode();
      if (Version != 0L) hash ^= Version.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Domain.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Domain);
      }
      if (Version != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Version);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Domain.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
      }
      if (Version != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Version);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OperatorSetIdProto other) {
      if (other == null) {
        return;
      }
      if (other.Domain.Length != 0) {
        Domain = other.Domain;
      }
      if (other.Version != 0L) {
        Version = other.Version;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Domain = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// External Models
  ///
  /// External models are uniquely identified by a (domain, name, version) tuple. 
  /// </summary>
  public sealed partial class ExternalModelProto : pb::IMessage<ExternalModelProto> {
    private static readonly pb::MessageParser<ExternalModelProto> _parser = new pb::MessageParser<ExternalModelProto>(() => new ExternalModelProto());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExternalModelProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ONNX.OnnxMlReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExternalModelProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExternalModelProto(ExternalModelProto other) : this() {
      domain_ = other.domain_;
      name_ = other.name_;
      version_ = other.version_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExternalModelProto Clone() {
      return new ExternalModelProto(this);
    }

    /// <summary>Field number for the "domain" field.</summary>
    public const int DomainFieldNumber = 1;
    private string domain_ = "";
    /// <summary>
    /// The domain of the operator set being identified.
    /// This field MUST be present in this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Domain {
      get { return domain_; }
      set {
        domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// The name of the model, that is, its main top-level graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 3;
    private long version_;
    /// <summary>
    /// The version of the model being identified.
    /// This field MUST be present in this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExternalModelProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExternalModelProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Domain != other.Domain) return false;
      if (Name != other.Name) return false;
      if (Version != other.Version) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Domain.Length != 0) hash ^= Domain.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Version != 0L) hash ^= Version.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Domain.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Domain);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (Version != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Version);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Domain.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Version != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Version);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExternalModelProto other) {
      if (other == null) {
        return;
      }
      if (other.Domain.Length != 0) {
        Domain = other.Domain;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Version != 0L) {
        Version = other.Version;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Domain = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 24: {
            Version = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
