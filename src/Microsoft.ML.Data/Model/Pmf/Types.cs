// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace LotusvNext.Types {

  /// <summary>Holder for reflection information generated from types.proto</summary>
  public static partial class TypesReflection {

    #region Descriptor
    /// <summary>File descriptor for types.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TypesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cgt0eXBlcy5wcm90bxIKTG90dXN2TmV4dBoOb25ueC1tbC5wcm90bzMiVwoO",
            "VmFsdWVJbmZvUHJvdG8SDAoEbmFtZRgBIAEoCRIjCgR0eXBlGAIgASgLMhUu",
            "TG90dXN2TmV4dC5UeXBlUHJvdG8SEgoKZG9jX3N0cmluZxgDIAEoCSL9EwoJ",
            "VHlwZVByb3RvEjwKC3RlbnNvcl90eXBlGAEgASgLMiUuTG90dXN2TmV4dC5U",
            "eXBlUHJvdG8uVGVuc29yVHlwZVByb3RvSAASSQoSc3BhcnNlX3RlbnNvcl90",
            "eXBlGAIgASgLMisuTG90dXN2TmV4dC5UeXBlUHJvdG8uU3BhcnNlVGVuc29y",
            "VHlwZVByb3RvSAASOwoNc2VxdWVuY2VfdHlwZRgEIAEoCzIiLkxvdHVzdk5l",
            "eHQuVHlwZVByb3RvLlNlcVR5cGVQcm90b0gAEjYKCG1hcF90eXBlGAUgASgL",
            "MiIuTG90dXN2TmV4dC5UeXBlUHJvdG8uTWFwVHlwZVByb3RvSAASQgoOdHlw",
            "ZV9yZWZlcmVuY2UYZCABKAsyKC5Mb3R1c3ZOZXh0LlR5cGVQcm90by5UeXBl",
            "UmVmZXJlbmNlUHJvdG9IABJCCg50eXBlX3BhcmFtZXRlchhlIAEoCzIoLkxv",
            "dHVzdk5leHQuVHlwZVByb3RvLlR5cGVQYXJhbWV0ZXJQcm90b0gAEjwKC3Jl",
            "Y29yZF90eXBlGGYgASgLMiUuTG90dXN2TmV4dC5UeXBlUHJvdG8uUmVjb3Jk",
            "VHlwZVByb3RvSAASOwoIbnVsbGFibGUYZyABKAsyJy5Mb3R1c3ZOZXh0LlR5",
            "cGVQcm90by5OdWxsYWJsZVR5cGVQcm90b0gAEkEKDWZ1bmN0aW9uX3R5cGUY",
            "aCABKAsyKC5Mb3R1c3ZOZXh0LlR5cGVQcm90by5TaWduYXR1cmVEZWNsUHJv",
            "dG9IABI6CgpuYW1lZF90eXBlGGkgASgLMiQuTG90dXN2TmV4dC5UeXBlUHJv",
            "dG8uTmFtZWRUeXBlUHJvdG9IABIxCgtzY2FsYXJfdHlwZRhqIAEoDjIaLm9u",
            "bnguVGVuc29yUHJvdG8uRGF0YVR5cGVIABI6Cgp0dXBsZV90eXBlGGsgASgL",
            "MiQuTG90dXN2TmV4dC5UeXBlUHJvdG8uVHVwbGVUeXBlUHJvdG9IABqgAQoP",
            "VGVuc29yVHlwZVByb3RvEi0KCWVsZW1fdHlwZRgBIAEoDjIaLm9ubnguVGVu",
            "c29yUHJvdG8uRGF0YVR5cGUSJQoFc2hhcGUYAiABKAsyFi5vbm54LlRlbnNv",
            "clNoYXBlUHJvdG8SNwoFcGFyYW0YZCABKAsyKC5Mb3R1c3ZOZXh0LlR5cGVQ",
            "cm90by5UeXBlUGFyYW1ldGVyUHJvdG8apgEKFVNwYXJzZVRlbnNvclR5cGVQ",
            "cm90bxItCgllbGVtX3R5cGUYASABKA4yGi5vbm54LlRlbnNvclByb3RvLkRh",
            "dGFUeXBlEiUKBXNoYXBlGAIgASgLMhYub25ueC5UZW5zb3JTaGFwZVByb3Rv",
            "EjcKBXBhcmFtGGQgASgLMiguTG90dXN2TmV4dC5UeXBlUHJvdG8uVHlwZVBh",
            "cmFtZXRlclByb3RvGvcCCg5OYW1lZFR5cGVQcm90bxIMCgRuYW1lGAEgASgJ",
            "EjgKBnBhcmFtcxgCIAMoCzIoLkxvdHVzdk5leHQuVHlwZVByb3RvLlR5cGVQ",
            "YXJhbWV0ZXJQcm90bxJLCgxpbnRfbWV0YWRhdGEYAyADKAsyNS5Mb3R1c3ZO",
            "ZXh0LlR5cGVQcm90by5OYW1lZFR5cGVQcm90by5JbnRNZXRhZGF0YUVudHJ5",
            "ElEKD3N0cmluZ19tZXRhZGF0YRgEIAMoCzI4LkxvdHVzdk5leHQuVHlwZVBy",
            "b3RvLk5hbWVkVHlwZVByb3RvLlN0cmluZ01ldGFkYXRhRW50cnkSEgoKZG9j",
            "X3N0cmluZxgFIAEoCRoyChBJbnRNZXRhZGF0YUVudHJ5EgsKA2tleRgBIAEo",
            "CRINCgV2YWx1ZRgCIAEoAzoCOAEaNQoTU3RyaW5nTWV0YWRhdGFFbnRyeRIL",
            "CgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGjYKDlR1cGxlVHlwZVBy",
            "b3RvEiQKBWl0ZW1zGAEgAygLMhUuTG90dXN2TmV4dC5UeXBlUHJvdG8aPQoP",
            "UmVjb3JkVHlwZVByb3RvEioKBmZpZWxkcxgBIAMoCzIaLkxvdHVzdk5leHQu",
            "VmFsdWVJbmZvUHJvdG8aOAoMU2VxVHlwZVByb3RvEigKCWVsZW1fdHlwZRgB",
            "IAEoCzIVLkxvdHVzdk5leHQuVHlwZVByb3RvGmcKDE1hcFR5cGVQcm90bxIs",
            "CghrZXlfdHlwZRgBIAEoDjIaLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUS",
            "KQoKdmFsdWVfdHlwZRgCIAEoCzIVLkxvdHVzdk5leHQuVHlwZVByb3RvGj4K",
            "EU51bGxhYmxlVHlwZVByb3RvEikKCnZhbHVlX3R5cGUYASABKAsyFS5Mb3R1",
            "c3ZOZXh0LlR5cGVQcm90bxq6AgoSVHlwZVJlZmVyZW5jZVByb3RvEhEKCXJl",
            "ZmVyZW5jZRgBIAEoCRJRCg10eXBlX2JpbmRpbmdzGAIgAygLMjouTG90dXN2",
            "TmV4dC5UeXBlUHJvdG8uVHlwZVJlZmVyZW5jZVByb3RvLlR5cGVCaW5kaW5n",
            "c0VudHJ5ElMKDnNoYXBlX2JpbmRpbmdzGAMgAygLMjsuTG90dXN2TmV4dC5U",
            "eXBlUHJvdG8uVHlwZVJlZmVyZW5jZVByb3RvLlNoYXBlQmluZGluZ3NFbnRy",
            "eRozChFUeXBlQmluZGluZ3NFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUY",
            "AiABKAk6AjgBGjQKElNoYXBlQmluZGluZ3NFbnRyeRILCgNrZXkYASABKAkS",
            "DQoFdmFsdWUYAiABKAQ6AjgBGicKElR5cGVQYXJhbWV0ZXJQcm90bxIRCglw",
            "YXJhbWV0ZXIYASABKAkadAoSUGFyYW1ldGVyRGVjbFByb3RvEgwKBG5hbWUY",
            "ASABKAkSIwoEdHlwZRgCIAEoCzIVLkxvdHVzdk5leHQuVHlwZVByb3RvEhIK",
            "CmRvY19zdHJpbmcYAyABKAkSEAoIdmFyaWFkaWMYZCABKAhKBQhuEMkBGvQB",
            "ChJTaWduYXR1cmVEZWNsUHJvdG8SPgoMaW5wdXRfcGFyYW1zGAEgAygLMigu",
            "TG90dXN2TmV4dC5UeXBlUHJvdG8uUGFyYW1ldGVyRGVjbFByb3RvEj8KDW91",
            "dHB1dF9wYXJhbXMYAiADKAsyKC5Mb3R1c3ZOZXh0LlR5cGVQcm90by5QYXJh",
            "bWV0ZXJEZWNsUHJvdG8SQgoQaW5wdXRfYXR0cmlidXRlcxgDIAMoCzIoLkxv",
            "dHVzdk5leHQuVHlwZVByb3RvLlBhcmFtZXRlckRlY2xQcm90bxISCgpkb2Nf",
            "c3RyaW5nGAQgASgJSgUIbhDJAUIHCgV2YWx1ZUoFCG4QyQFCE6oCEExvdHVz",
            "dk5leHQuVHlwZXNiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::ONNX.OnnxMlReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.ValueInfoProto), global::LotusvNext.Types.ValueInfoProto.Parser, new[]{ "Name", "Type", "DocString" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto), global::LotusvNext.Types.TypeProto.Parser, new[]{ "TensorType", "SparseTensorType", "SequenceType", "MapType", "TypeReference", "TypeParameter", "RecordType", "Nullable", "FunctionType", "NamedType", "ScalarType", "TupleType" }, new[]{ "Value" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.TensorTypeProto), global::LotusvNext.Types.TypeProto.Types.TensorTypeProto.Parser, new[]{ "ElemType", "Shape", "Param" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.SparseTensorTypeProto), global::LotusvNext.Types.TypeProto.Types.SparseTensorTypeProto.Parser, new[]{ "ElemType", "Shape", "Param" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.NamedTypeProto), global::LotusvNext.Types.TypeProto.Types.NamedTypeProto.Parser, new[]{ "Name", "Params", "IntMetadata", "StringMetadata", "DocString" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.TupleTypeProto), global::LotusvNext.Types.TypeProto.Types.TupleTypeProto.Parser, new[]{ "Items" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.RecordTypeProto), global::LotusvNext.Types.TypeProto.Types.RecordTypeProto.Parser, new[]{ "Fields" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.SeqTypeProto), global::LotusvNext.Types.TypeProto.Types.SeqTypeProto.Parser, new[]{ "ElemType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.MapTypeProto), global::LotusvNext.Types.TypeProto.Types.MapTypeProto.Parser, new[]{ "KeyType", "ValueType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.NullableTypeProto), global::LotusvNext.Types.TypeProto.Types.NullableTypeProto.Parser, new[]{ "ValueType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.TypeReferenceProto), global::LotusvNext.Types.TypeProto.Types.TypeReferenceProto.Parser, new[]{ "Reference", "TypeBindings", "ShapeBindings" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.TypeParameterProto), global::LotusvNext.Types.TypeProto.Types.TypeParameterProto.Parser, new[]{ "Parameter" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto), global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto.Parser, new[]{ "Name", "Type", "DocString", "Variadic" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto), global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto.Parser, new[]{ "InputParams", "OutputParams", "InputAttributes", "DocString" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Defines information on value, including the name, the type, and
  /// the shape of the value.
  /// </summary>
  public sealed partial class ValueInfoProto : pb::IMessage<ValueInfoProto> {
    private static readonly pb::MessageParser<ValueInfoProto> _parser = new pb::MessageParser<ValueInfoProto>(() => new ValueInfoProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ValueInfoProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusvNext.Types.TypesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueInfoProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueInfoProto(ValueInfoProto other) : this() {
      name_ = other.name_;
      Type = other.type_ != null ? other.Type.Clone() : null;
      docString_ = other.docString_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueInfoProto Clone() {
      return new ValueInfoProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// This field MUST be present in this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::LotusvNext.Types.TypeProto type_;
    /// <summary>
    /// This field MUST be present in this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 3;
    private string docString_ = "";
    /// <summary>
    /// An human-readable documentation for this node in the graph.
    /// This text MAY contain Markdown markup that conforms to http://commonmark.org/.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ValueInfoProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ValueInfoProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Type, other.Type)) return false;
      if (DocString != other.DocString) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (type_ != null) hash ^= Type.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (type_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Type);
      }
      if (DocString.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DocString);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (type_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Type);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ValueInfoProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.type_ != null) {
        if (type_ == null) {
          type_ = new global::LotusvNext.Types.TypeProto();
        }
        Type.MergeFrom(other.Type);
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (type_ == null) {
              type_ = new global::LotusvNext.Types.TypeProto();
            }
            input.ReadMessage(type_);
            break;
          }
          case 26: {
            DocString = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// This is an extension of the LotusIR type definition. New properties
  /// start at 100.
  /// </summary>
  public sealed partial class TypeProto : pb::IMessage<TypeProto> {
    private static readonly pb::MessageParser<TypeProto> _parser = new pb::MessageParser<TypeProto>(() => new TypeProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TypeProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusvNext.Types.TypesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeProto(TypeProto other) : this() {
      switch (other.ValueCase) {
        case ValueOneofCase.TensorType:
          TensorType = other.TensorType.Clone();
          break;
        case ValueOneofCase.SparseTensorType:
          SparseTensorType = other.SparseTensorType.Clone();
          break;
        case ValueOneofCase.SequenceType:
          SequenceType = other.SequenceType.Clone();
          break;
        case ValueOneofCase.MapType:
          MapType = other.MapType.Clone();
          break;
        case ValueOneofCase.TypeReference:
          TypeReference = other.TypeReference.Clone();
          break;
        case ValueOneofCase.TypeParameter:
          TypeParameter = other.TypeParameter.Clone();
          break;
        case ValueOneofCase.RecordType:
          RecordType = other.RecordType.Clone();
          break;
        case ValueOneofCase.Nullable:
          Nullable = other.Nullable.Clone();
          break;
        case ValueOneofCase.FunctionType:
          FunctionType = other.FunctionType.Clone();
          break;
        case ValueOneofCase.NamedType:
          NamedType = other.NamedType.Clone();
          break;
        case ValueOneofCase.ScalarType:
          ScalarType = other.ScalarType;
          break;
        case ValueOneofCase.TupleType:
          TupleType = other.TupleType.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeProto Clone() {
      return new TypeProto(this);
    }

    /// <summary>Field number for the "tensor_type" field.</summary>
    public const int TensorTypeFieldNumber = 1;
    /// <summary>
    /// The type of a tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.TensorTypeProto TensorType {
      get { return valueCase_ == ValueOneofCase.TensorType ? (global::LotusvNext.Types.TypeProto.Types.TensorTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.TensorType;
      }
    }

    /// <summary>Field number for the "sparse_tensor_type" field.</summary>
    public const int SparseTensorTypeFieldNumber = 2;
    /// <summary>
    /// The type of a sparse tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.SparseTensorTypeProto SparseTensorType {
      get { return valueCase_ == ValueOneofCase.SparseTensorType ? (global::LotusvNext.Types.TypeProto.Types.SparseTensorTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.SparseTensorType;
      }
    }

    /// <summary>Field number for the "sequence_type" field.</summary>
    public const int SequenceTypeFieldNumber = 4;
    /// <summary>
    /// The type of a sequence.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.SeqTypeProto SequenceType {
      get { return valueCase_ == ValueOneofCase.SequenceType ? (global::LotusvNext.Types.TypeProto.Types.SeqTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.SequenceType;
      }
    }

    /// <summary>Field number for the "map_type" field.</summary>
    public const int MapTypeFieldNumber = 5;
    /// <summary>
    /// The type of a map.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.MapTypeProto MapType {
      get { return valueCase_ == ValueOneofCase.MapType ? (global::LotusvNext.Types.TypeProto.Types.MapTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.MapType;
      }
    }

    /// <summary>Field number for the "type_reference" field.</summary>
    public const int TypeReferenceFieldNumber = 100;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.TypeReferenceProto TypeReference {
      get { return valueCase_ == ValueOneofCase.TypeReference ? (global::LotusvNext.Types.TypeProto.Types.TypeReferenceProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.TypeReference;
      }
    }

    /// <summary>Field number for the "type_parameter" field.</summary>
    public const int TypeParameterFieldNumber = 101;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.TypeParameterProto TypeParameter {
      get { return valueCase_ == ValueOneofCase.TypeParameter ? (global::LotusvNext.Types.TypeProto.Types.TypeParameterProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.TypeParameter;
      }
    }

    /// <summary>Field number for the "record_type" field.</summary>
    public const int RecordTypeFieldNumber = 102;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.RecordTypeProto RecordType {
      get { return valueCase_ == ValueOneofCase.RecordType ? (global::LotusvNext.Types.TypeProto.Types.RecordTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.RecordType;
      }
    }

    /// <summary>Field number for the "nullable" field.</summary>
    public const int NullableFieldNumber = 103;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.NullableTypeProto Nullable {
      get { return valueCase_ == ValueOneofCase.Nullable ? (global::LotusvNext.Types.TypeProto.Types.NullableTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.Nullable;
      }
    }

    /// <summary>Field number for the "function_type" field.</summary>
    public const int FunctionTypeFieldNumber = 104;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto FunctionType {
      get { return valueCase_ == ValueOneofCase.FunctionType ? (global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.FunctionType;
      }
    }

    /// <summary>Field number for the "named_type" field.</summary>
    public const int NamedTypeFieldNumber = 105;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.NamedTypeProto NamedType {
      get { return valueCase_ == ValueOneofCase.NamedType ? (global::LotusvNext.Types.TypeProto.Types.NamedTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.NamedType;
      }
    }

    /// <summary>Field number for the "scalar_type" field.</summary>
    public const int ScalarTypeFieldNumber = 106;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ONNX.TensorProto.Types.DataType ScalarType {
      get { return valueCase_ == ValueOneofCase.ScalarType ? (global::ONNX.TensorProto.Types.DataType) value_ : 0; }
      set {
        value_ = value;
        valueCase_ = ValueOneofCase.ScalarType;
      }
    }

    /// <summary>Field number for the "tuple_type" field.</summary>
    public const int TupleTypeFieldNumber = 107;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.TupleTypeProto TupleType {
      get { return valueCase_ == ValueOneofCase.TupleType ? (global::LotusvNext.Types.TypeProto.Types.TupleTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.TupleType;
      }
    }

    private object value_;
    /// <summary>Enum of possible cases for the "value" oneof.</summary>
    public enum ValueOneofCase {
      None = 0,
      TensorType = 1,
      SparseTensorType = 2,
      SequenceType = 4,
      MapType = 5,
      TypeReference = 100,
      TypeParameter = 101,
      RecordType = 102,
      Nullable = 103,
      FunctionType = 104,
      NamedType = 105,
      ScalarType = 106,
      TupleType = 107,
    }
    private ValueOneofCase valueCase_ = ValueOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueOneofCase ValueCase {
      get { return valueCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValue() {
      valueCase_ = ValueOneofCase.None;
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TypeProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TypeProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TensorType, other.TensorType)) return false;
      if (!object.Equals(SparseTensorType, other.SparseTensorType)) return false;
      if (!object.Equals(SequenceType, other.SequenceType)) return false;
      if (!object.Equals(MapType, other.MapType)) return false;
      if (!object.Equals(TypeReference, other.TypeReference)) return false;
      if (!object.Equals(TypeParameter, other.TypeParameter)) return false;
      if (!object.Equals(RecordType, other.RecordType)) return false;
      if (!object.Equals(Nullable, other.Nullable)) return false;
      if (!object.Equals(FunctionType, other.FunctionType)) return false;
      if (!object.Equals(NamedType, other.NamedType)) return false;
      if (ScalarType != other.ScalarType) return false;
      if (!object.Equals(TupleType, other.TupleType)) return false;
      if (ValueCase != other.ValueCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (valueCase_ == ValueOneofCase.TensorType) hash ^= TensorType.GetHashCode();
      if (valueCase_ == ValueOneofCase.SparseTensorType) hash ^= SparseTensorType.GetHashCode();
      if (valueCase_ == ValueOneofCase.SequenceType) hash ^= SequenceType.GetHashCode();
      if (valueCase_ == ValueOneofCase.MapType) hash ^= MapType.GetHashCode();
      if (valueCase_ == ValueOneofCase.TypeReference) hash ^= TypeReference.GetHashCode();
      if (valueCase_ == ValueOneofCase.TypeParameter) hash ^= TypeParameter.GetHashCode();
      if (valueCase_ == ValueOneofCase.RecordType) hash ^= RecordType.GetHashCode();
      if (valueCase_ == ValueOneofCase.Nullable) hash ^= Nullable.GetHashCode();
      if (valueCase_ == ValueOneofCase.FunctionType) hash ^= FunctionType.GetHashCode();
      if (valueCase_ == ValueOneofCase.NamedType) hash ^= NamedType.GetHashCode();
      if (valueCase_ == ValueOneofCase.ScalarType) hash ^= ScalarType.GetHashCode();
      if (valueCase_ == ValueOneofCase.TupleType) hash ^= TupleType.GetHashCode();
      hash ^= (int) valueCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (valueCase_ == ValueOneofCase.TensorType) {
        output.WriteRawTag(10);
        output.WriteMessage(TensorType);
      }
      if (valueCase_ == ValueOneofCase.SparseTensorType) {
        output.WriteRawTag(18);
        output.WriteMessage(SparseTensorType);
      }
      if (valueCase_ == ValueOneofCase.SequenceType) {
        output.WriteRawTag(34);
        output.WriteMessage(SequenceType);
      }
      if (valueCase_ == ValueOneofCase.MapType) {
        output.WriteRawTag(42);
        output.WriteMessage(MapType);
      }
      if (valueCase_ == ValueOneofCase.TypeReference) {
        output.WriteRawTag(162, 6);
        output.WriteMessage(TypeReference);
      }
      if (valueCase_ == ValueOneofCase.TypeParameter) {
        output.WriteRawTag(170, 6);
        output.WriteMessage(TypeParameter);
      }
      if (valueCase_ == ValueOneofCase.RecordType) {
        output.WriteRawTag(178, 6);
        output.WriteMessage(RecordType);
      }
      if (valueCase_ == ValueOneofCase.Nullable) {
        output.WriteRawTag(186, 6);
        output.WriteMessage(Nullable);
      }
      if (valueCase_ == ValueOneofCase.FunctionType) {
        output.WriteRawTag(194, 6);
        output.WriteMessage(FunctionType);
      }
      if (valueCase_ == ValueOneofCase.NamedType) {
        output.WriteRawTag(202, 6);
        output.WriteMessage(NamedType);
      }
      if (valueCase_ == ValueOneofCase.ScalarType) {
        output.WriteRawTag(208, 6);
        output.WriteEnum((int) ScalarType);
      }
      if (valueCase_ == ValueOneofCase.TupleType) {
        output.WriteRawTag(218, 6);
        output.WriteMessage(TupleType);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (valueCase_ == ValueOneofCase.TensorType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TensorType);
      }
      if (valueCase_ == ValueOneofCase.SparseTensorType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SparseTensorType);
      }
      if (valueCase_ == ValueOneofCase.SequenceType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SequenceType);
      }
      if (valueCase_ == ValueOneofCase.MapType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MapType);
      }
      if (valueCase_ == ValueOneofCase.TypeReference) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TypeReference);
      }
      if (valueCase_ == ValueOneofCase.TypeParameter) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TypeParameter);
      }
      if (valueCase_ == ValueOneofCase.RecordType) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RecordType);
      }
      if (valueCase_ == ValueOneofCase.Nullable) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Nullable);
      }
      if (valueCase_ == ValueOneofCase.FunctionType) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(FunctionType);
      }
      if (valueCase_ == ValueOneofCase.NamedType) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(NamedType);
      }
      if (valueCase_ == ValueOneofCase.ScalarType) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ScalarType);
      }
      if (valueCase_ == ValueOneofCase.TupleType) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TupleType);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TypeProto other) {
      if (other == null) {
        return;
      }
      switch (other.ValueCase) {
        case ValueOneofCase.TensorType:
          TensorType = other.TensorType;
          break;
        case ValueOneofCase.SparseTensorType:
          SparseTensorType = other.SparseTensorType;
          break;
        case ValueOneofCase.SequenceType:
          SequenceType = other.SequenceType;
          break;
        case ValueOneofCase.MapType:
          MapType = other.MapType;
          break;
        case ValueOneofCase.TypeReference:
          TypeReference = other.TypeReference;
          break;
        case ValueOneofCase.TypeParameter:
          TypeParameter = other.TypeParameter;
          break;
        case ValueOneofCase.RecordType:
          RecordType = other.RecordType;
          break;
        case ValueOneofCase.Nullable:
          Nullable = other.Nullable;
          break;
        case ValueOneofCase.FunctionType:
          FunctionType = other.FunctionType;
          break;
        case ValueOneofCase.NamedType:
          NamedType = other.NamedType;
          break;
        case ValueOneofCase.ScalarType:
          ScalarType = other.ScalarType;
          break;
        case ValueOneofCase.TupleType:
          TupleType = other.TupleType;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            global::LotusvNext.Types.TypeProto.Types.TensorTypeProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.TensorTypeProto();
            if (valueCase_ == ValueOneofCase.TensorType) {
              subBuilder.MergeFrom(TensorType);
            }
            input.ReadMessage(subBuilder);
            TensorType = subBuilder;
            break;
          }
          case 18: {
            global::LotusvNext.Types.TypeProto.Types.SparseTensorTypeProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.SparseTensorTypeProto();
            if (valueCase_ == ValueOneofCase.SparseTensorType) {
              subBuilder.MergeFrom(SparseTensorType);
            }
            input.ReadMessage(subBuilder);
            SparseTensorType = subBuilder;
            break;
          }
          case 34: {
            global::LotusvNext.Types.TypeProto.Types.SeqTypeProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.SeqTypeProto();
            if (valueCase_ == ValueOneofCase.SequenceType) {
              subBuilder.MergeFrom(SequenceType);
            }
            input.ReadMessage(subBuilder);
            SequenceType = subBuilder;
            break;
          }
          case 42: {
            global::LotusvNext.Types.TypeProto.Types.MapTypeProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.MapTypeProto();
            if (valueCase_ == ValueOneofCase.MapType) {
              subBuilder.MergeFrom(MapType);
            }
            input.ReadMessage(subBuilder);
            MapType = subBuilder;
            break;
          }
          case 802: {
            global::LotusvNext.Types.TypeProto.Types.TypeReferenceProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.TypeReferenceProto();
            if (valueCase_ == ValueOneofCase.TypeReference) {
              subBuilder.MergeFrom(TypeReference);
            }
            input.ReadMessage(subBuilder);
            TypeReference = subBuilder;
            break;
          }
          case 810: {
            global::LotusvNext.Types.TypeProto.Types.TypeParameterProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.TypeParameterProto();
            if (valueCase_ == ValueOneofCase.TypeParameter) {
              subBuilder.MergeFrom(TypeParameter);
            }
            input.ReadMessage(subBuilder);
            TypeParameter = subBuilder;
            break;
          }
          case 818: {
            global::LotusvNext.Types.TypeProto.Types.RecordTypeProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.RecordTypeProto();
            if (valueCase_ == ValueOneofCase.RecordType) {
              subBuilder.MergeFrom(RecordType);
            }
            input.ReadMessage(subBuilder);
            RecordType = subBuilder;
            break;
          }
          case 826: {
            global::LotusvNext.Types.TypeProto.Types.NullableTypeProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.NullableTypeProto();
            if (valueCase_ == ValueOneofCase.Nullable) {
              subBuilder.MergeFrom(Nullable);
            }
            input.ReadMessage(subBuilder);
            Nullable = subBuilder;
            break;
          }
          case 834: {
            global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto();
            if (valueCase_ == ValueOneofCase.FunctionType) {
              subBuilder.MergeFrom(FunctionType);
            }
            input.ReadMessage(subBuilder);
            FunctionType = subBuilder;
            break;
          }
          case 842: {
            global::LotusvNext.Types.TypeProto.Types.NamedTypeProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.NamedTypeProto();
            if (valueCase_ == ValueOneofCase.NamedType) {
              subBuilder.MergeFrom(NamedType);
            }
            input.ReadMessage(subBuilder);
            NamedType = subBuilder;
            break;
          }
          case 848: {
            value_ = input.ReadEnum();
            valueCase_ = ValueOneofCase.ScalarType;
            break;
          }
          case 858: {
            global::LotusvNext.Types.TypeProto.Types.TupleTypeProto subBuilder = new global::LotusvNext.Types.TypeProto.Types.TupleTypeProto();
            if (valueCase_ == ValueOneofCase.TupleType) {
              subBuilder.MergeFrom(TupleType);
            }
            input.ReadMessage(subBuilder);
            TupleType = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TypeProto message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class TensorTypeProto : pb::IMessage<TensorTypeProto> {
        private static readonly pb::MessageParser<TensorTypeProto> _parser = new pb::MessageParser<TensorTypeProto>(() => new TensorTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TensorTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorTypeProto(TensorTypeProto other) : this() {
          elemType_ = other.elemType_;
          Shape = other.shape_ != null ? other.Shape.Clone() : null;
          Param = other.param_ != null ? other.Param.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorTypeProto Clone() {
          return new TensorTypeProto(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private global::ONNX.TensorProto.Types.DataType elemType_ = 0;
        /// <summary>
        /// This field MUST NOT have the value of UNDEFINED
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorProto.Types.DataType ElemType {
          get { return elemType_; }
          set {
            elemType_ = value;
          }
        }

        /// <summary>Field number for the "shape" field.</summary>
        public const int ShapeFieldNumber = 2;
        private global::ONNX.TensorShapeProto shape_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorShapeProto Shape {
          get { return shape_; }
          set {
            shape_ = value;
          }
        }

        /// <summary>Field number for the "param" field.</summary>
        public const int ParamFieldNumber = 100;
        private global::LotusvNext.Types.TypeProto.Types.TypeParameterProto param_;
        /// <summary>
        /// If this is present, then elem_type should be UNDEFINED.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusvNext.Types.TypeProto.Types.TypeParameterProto Param {
          get { return param_; }
          set {
            param_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TensorTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TensorTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ElemType != other.ElemType) return false;
          if (!object.Equals(Shape, other.Shape)) return false;
          if (!object.Equals(Param, other.Param)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (ElemType != 0) hash ^= ElemType.GetHashCode();
          if (shape_ != null) hash ^= Shape.GetHashCode();
          if (param_ != null) hash ^= Param.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (ElemType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) ElemType);
          }
          if (shape_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Shape);
          }
          if (param_ != null) {
            output.WriteRawTag(162, 6);
            output.WriteMessage(Param);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (ElemType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ElemType);
          }
          if (shape_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Shape);
          }
          if (param_ != null) {
            size += 2 + pb::CodedOutputStream.ComputeMessageSize(Param);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TensorTypeProto other) {
          if (other == null) {
            return;
          }
          if (other.ElemType != 0) {
            ElemType = other.ElemType;
          }
          if (other.shape_ != null) {
            if (shape_ == null) {
              shape_ = new global::ONNX.TensorShapeProto();
            }
            Shape.MergeFrom(other.Shape);
          }
          if (other.param_ != null) {
            if (param_ == null) {
              param_ = new global::LotusvNext.Types.TypeProto.Types.TypeParameterProto();
            }
            Param.MergeFrom(other.Param);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                elemType_ = (global::ONNX.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
              case 18: {
                if (shape_ == null) {
                  shape_ = new global::ONNX.TensorShapeProto();
                }
                input.ReadMessage(shape_);
                break;
              }
              case 802: {
                if (param_ == null) {
                  param_ = new global::LotusvNext.Types.TypeProto.Types.TypeParameterProto();
                }
                input.ReadMessage(param_);
                break;
              }
            }
          }
        }

      }

      public sealed partial class SparseTensorTypeProto : pb::IMessage<SparseTensorTypeProto> {
        private static readonly pb::MessageParser<SparseTensorTypeProto> _parser = new pb::MessageParser<SparseTensorTypeProto>(() => new SparseTensorTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SparseTensorTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensorTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensorTypeProto(SparseTensorTypeProto other) : this() {
          elemType_ = other.elemType_;
          Shape = other.shape_ != null ? other.Shape.Clone() : null;
          Param = other.param_ != null ? other.Param.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensorTypeProto Clone() {
          return new SparseTensorTypeProto(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private global::ONNX.TensorProto.Types.DataType elemType_ = 0;
        /// <summary>
        /// This field MUST NOT have the value of UNDEFINED
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorProto.Types.DataType ElemType {
          get { return elemType_; }
          set {
            elemType_ = value;
          }
        }

        /// <summary>Field number for the "shape" field.</summary>
        public const int ShapeFieldNumber = 2;
        private global::ONNX.TensorShapeProto shape_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorShapeProto Shape {
          get { return shape_; }
          set {
            shape_ = value;
          }
        }

        /// <summary>Field number for the "param" field.</summary>
        public const int ParamFieldNumber = 100;
        private global::LotusvNext.Types.TypeProto.Types.TypeParameterProto param_;
        /// <summary>
        /// If this is present, then elem_type should be UNDEFINED.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusvNext.Types.TypeProto.Types.TypeParameterProto Param {
          get { return param_; }
          set {
            param_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SparseTensorTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SparseTensorTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ElemType != other.ElemType) return false;
          if (!object.Equals(Shape, other.Shape)) return false;
          if (!object.Equals(Param, other.Param)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (ElemType != 0) hash ^= ElemType.GetHashCode();
          if (shape_ != null) hash ^= Shape.GetHashCode();
          if (param_ != null) hash ^= Param.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (ElemType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) ElemType);
          }
          if (shape_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Shape);
          }
          if (param_ != null) {
            output.WriteRawTag(162, 6);
            output.WriteMessage(Param);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (ElemType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ElemType);
          }
          if (shape_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Shape);
          }
          if (param_ != null) {
            size += 2 + pb::CodedOutputStream.ComputeMessageSize(Param);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SparseTensorTypeProto other) {
          if (other == null) {
            return;
          }
          if (other.ElemType != 0) {
            ElemType = other.ElemType;
          }
          if (other.shape_ != null) {
            if (shape_ == null) {
              shape_ = new global::ONNX.TensorShapeProto();
            }
            Shape.MergeFrom(other.Shape);
          }
          if (other.param_ != null) {
            if (param_ == null) {
              param_ = new global::LotusvNext.Types.TypeProto.Types.TypeParameterProto();
            }
            Param.MergeFrom(other.Param);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                elemType_ = (global::ONNX.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
              case 18: {
                if (shape_ == null) {
                  shape_ = new global::ONNX.TensorShapeProto();
                }
                input.ReadMessage(shape_);
                break;
              }
              case 802: {
                if (param_ == null) {
                  param_ = new global::LotusvNext.Types.TypeProto.Types.TypeParameterProto();
                }
                input.ReadMessage(param_);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Used to define any number of specific, named typed, that defy
      /// definition through other means, but values of which pass through
      /// code opaquely.
      /// </summary>
      public sealed partial class NamedTypeProto : pb::IMessage<NamedTypeProto> {
        private static readonly pb::MessageParser<NamedTypeProto> _parser = new pb::MessageParser<NamedTypeProto>(() => new NamedTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<NamedTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NamedTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NamedTypeProto(NamedTypeProto other) : this() {
          name_ = other.name_;
          params_ = other.params_.Clone();
          intMetadata_ = other.intMetadata_.Clone();
          stringMetadata_ = other.stringMetadata_.Clone();
          docString_ = other.docString_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NamedTypeProto Clone() {
          return new NamedTypeProto(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The name of the type
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "params" field.</summary>
        public const int ParamsFieldNumber = 2;
        private static readonly pb::FieldCodec<global::LotusvNext.Types.TypeProto.Types.TypeParameterProto> _repeated_params_codec
            = pb::FieldCodec.ForMessage(18, global::LotusvNext.Types.TypeProto.Types.TypeParameterProto.Parser);
        private readonly pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.TypeParameterProto> params_ = new pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.TypeParameterProto>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.TypeParameterProto> Params {
          get { return params_; }
        }

        /// <summary>Field number for the "int_metadata" field.</summary>
        public const int IntMetadataFieldNumber = 3;
        private static readonly pbc::MapField<string, long>.Codec _map_intMetadata_codec
            = new pbc::MapField<string, long>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForInt64(16), 26);
        private readonly pbc::MapField<string, long> intMetadata_ = new pbc::MapField<string, long>();
        /// <summary>
        /// Type metadata, all integers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, long> IntMetadata {
          get { return intMetadata_; }
        }

        /// <summary>Field number for the "string_metadata" field.</summary>
        public const int StringMetadataFieldNumber = 4;
        private static readonly pbc::MapField<string, string>.Codec _map_stringMetadata_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 34);
        private readonly pbc::MapField<string, string> stringMetadata_ = new pbc::MapField<string, string>();
        /// <summary>
        /// Type metadata, all strings.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, string> StringMetadata {
          get { return stringMetadata_; }
        }

        /// <summary>Field number for the "doc_string" field.</summary>
        public const int DocStringFieldNumber = 5;
        private string docString_ = "";
        /// <summary>
        /// A human-readable documentation for this node in the graph.
        /// This text MAY contain Markdown markup that conforms to http://commonmark.org/.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string DocString {
          get { return docString_; }
          set {
            docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as NamedTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(NamedTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if(!params_.Equals(other.params_)) return false;
          if (!IntMetadata.Equals(other.IntMetadata)) return false;
          if (!StringMetadata.Equals(other.StringMetadata)) return false;
          if (DocString != other.DocString) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          hash ^= params_.GetHashCode();
          hash ^= IntMetadata.GetHashCode();
          hash ^= StringMetadata.GetHashCode();
          if (DocString.Length != 0) hash ^= DocString.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          params_.WriteTo(output, _repeated_params_codec);
          intMetadata_.WriteTo(output, _map_intMetadata_codec);
          stringMetadata_.WriteTo(output, _map_stringMetadata_codec);
          if (DocString.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(DocString);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          size += params_.CalculateSize(_repeated_params_codec);
          size += intMetadata_.CalculateSize(_map_intMetadata_codec);
          size += stringMetadata_.CalculateSize(_map_stringMetadata_codec);
          if (DocString.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(NamedTypeProto other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          params_.Add(other.params_);
          intMetadata_.Add(other.intMetadata_);
          stringMetadata_.Add(other.stringMetadata_);
          if (other.DocString.Length != 0) {
            DocString = other.DocString;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                params_.AddEntriesFrom(input, _repeated_params_codec);
                break;
              }
              case 26: {
                intMetadata_.AddEntriesFrom(input, _map_intMetadata_codec);
                break;
              }
              case 34: {
                stringMetadata_.AddEntriesFrom(input, _map_stringMetadata_codec);
                break;
              }
              case 42: {
                DocString = input.ReadString();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// message T { ... }
      /// </summary>
      public sealed partial class TupleTypeProto : pb::IMessage<TupleTypeProto> {
        private static readonly pb::MessageParser<TupleTypeProto> _parser = new pb::MessageParser<TupleTypeProto>(() => new TupleTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TupleTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleTypeProto(TupleTypeProto other) : this() {
          items_ = other.items_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleTypeProto Clone() {
          return new TupleTypeProto(this);
        }

        /// <summary>Field number for the "items" field.</summary>
        public const int ItemsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::LotusvNext.Types.TypeProto> _repeated_items_codec
            = pb::FieldCodec.ForMessage(10, global::LotusvNext.Types.TypeProto.Parser);
        private readonly pbc::RepeatedField<global::LotusvNext.Types.TypeProto> items_ = new pbc::RepeatedField<global::LotusvNext.Types.TypeProto>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::LotusvNext.Types.TypeProto> Items {
          get { return items_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TupleTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TupleTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!items_.Equals(other.items_)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= items_.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          items_.WriteTo(output, _repeated_items_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += items_.CalculateSize(_repeated_items_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TupleTypeProto other) {
          if (other == null) {
            return;
          }
          items_.Add(other.items_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                items_.AddEntriesFrom(input, _repeated_items_codec);
                break;
              }
            }
          }
        }

      }

      public sealed partial class RecordTypeProto : pb::IMessage<RecordTypeProto> {
        private static readonly pb::MessageParser<RecordTypeProto> _parser = new pb::MessageParser<RecordTypeProto>(() => new RecordTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RecordTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RecordTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RecordTypeProto(RecordTypeProto other) : this() {
          fields_ = other.fields_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RecordTypeProto Clone() {
          return new RecordTypeProto(this);
        }

        /// <summary>Field number for the "fields" field.</summary>
        public const int FieldsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::LotusvNext.Types.ValueInfoProto> _repeated_fields_codec
            = pb::FieldCodec.ForMessage(10, global::LotusvNext.Types.ValueInfoProto.Parser);
        private readonly pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto> fields_ = new pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto>();
        /// <summary>
        /// The type and shape of each field
        /// is described by a ValueInfoProto. The field
        /// names must be unique.
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto> Fields {
          get { return fields_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RecordTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RecordTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!fields_.Equals(other.fields_)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= fields_.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          fields_.WriteTo(output, _repeated_fields_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += fields_.CalculateSize(_repeated_fields_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RecordTypeProto other) {
          if (other == null) {
            return;
          }
          fields_.Add(other.fields_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                fields_.AddEntriesFrom(input, _repeated_fields_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// repeated T
      /// </summary>
      public sealed partial class SeqTypeProto : pb::IMessage<SeqTypeProto> {
        private static readonly pb::MessageParser<SeqTypeProto> _parser = new pb::MessageParser<SeqTypeProto>(() => new SeqTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SeqTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SeqTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SeqTypeProto(SeqTypeProto other) : this() {
          ElemType = other.elemType_ != null ? other.ElemType.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SeqTypeProto Clone() {
          return new SeqTypeProto(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private global::LotusvNext.Types.TypeProto elemType_;
        /// <summary>
        /// The type and shape of each element of the sequence.
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusvNext.Types.TypeProto ElemType {
          get { return elemType_; }
          set {
            elemType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SeqTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SeqTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ElemType, other.ElemType)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (elemType_ != null) hash ^= ElemType.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (elemType_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(ElemType);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (elemType_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ElemType);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SeqTypeProto other) {
          if (other == null) {
            return;
          }
          if (other.elemType_ != null) {
            if (elemType_ == null) {
              elemType_ = new global::LotusvNext.Types.TypeProto();
            }
            ElemType.MergeFrom(other.ElemType);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                if (elemType_ == null) {
                  elemType_ = new global::LotusvNext.Types.TypeProto();
                }
                input.ReadMessage(elemType_);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// map&lt;K,V>
      /// </summary>
      public sealed partial class MapTypeProto : pb::IMessage<MapTypeProto> {
        private static readonly pb::MessageParser<MapTypeProto> _parser = new pb::MessageParser<MapTypeProto>(() => new MapTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MapTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapTypeProto(MapTypeProto other) : this() {
          keyType_ = other.keyType_;
          ValueType = other.valueType_ != null ? other.ValueType.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapTypeProto Clone() {
          return new MapTypeProto(this);
        }

        /// <summary>Field number for the "key_type" field.</summary>
        public const int KeyTypeFieldNumber = 1;
        private global::ONNX.TensorProto.Types.DataType keyType_ = 0;
        /// <summary>
        /// This field MUST be present for this version of the IR.
        /// This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::ONNX.TensorProto.Types.DataType KeyType {
          get { return keyType_; }
          set {
            keyType_ = value;
          }
        }

        /// <summary>Field number for the "value_type" field.</summary>
        public const int ValueTypeFieldNumber = 2;
        private global::LotusvNext.Types.TypeProto valueType_;
        /// <summary>
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusvNext.Types.TypeProto ValueType {
          get { return valueType_; }
          set {
            valueType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as MapTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MapTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (KeyType != other.KeyType) return false;
          if (!object.Equals(ValueType, other.ValueType)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (KeyType != 0) hash ^= KeyType.GetHashCode();
          if (valueType_ != null) hash ^= ValueType.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (KeyType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) KeyType);
          }
          if (valueType_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(ValueType);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (KeyType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) KeyType);
          }
          if (valueType_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValueType);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MapTypeProto other) {
          if (other == null) {
            return;
          }
          if (other.KeyType != 0) {
            KeyType = other.KeyType;
          }
          if (other.valueType_ != null) {
            if (valueType_ == null) {
              valueType_ = new global::LotusvNext.Types.TypeProto();
            }
            ValueType.MergeFrom(other.ValueType);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                keyType_ = (global::ONNX.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
              case 18: {
                if (valueType_ == null) {
                  valueType_ = new global::LotusvNext.Types.TypeProto();
                }
                input.ReadMessage(valueType_);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Null types represent missing values when in union with another type.
      /// </summary>
      public sealed partial class NullableTypeProto : pb::IMessage<NullableTypeProto> {
        private static readonly pb::MessageParser<NullableTypeProto> _parser = new pb::MessageParser<NullableTypeProto>(() => new NullableTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<NullableTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[7]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NullableTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NullableTypeProto(NullableTypeProto other) : this() {
          ValueType = other.valueType_ != null ? other.ValueType.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NullableTypeProto Clone() {
          return new NullableTypeProto(this);
        }

        /// <summary>Field number for the "value_type" field.</summary>
        public const int ValueTypeFieldNumber = 1;
        private global::LotusvNext.Types.TypeProto valueType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusvNext.Types.TypeProto ValueType {
          get { return valueType_; }
          set {
            valueType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as NullableTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(NullableTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ValueType, other.ValueType)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (valueType_ != null) hash ^= ValueType.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (valueType_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(ValueType);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (valueType_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValueType);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(NullableTypeProto other) {
          if (other == null) {
            return;
          }
          if (other.valueType_ != null) {
            if (valueType_ == null) {
              valueType_ = new global::LotusvNext.Types.TypeProto();
            }
            ValueType.MergeFrom(other.ValueType);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                if (valueType_ == null) {
                  valueType_ = new global::LotusvNext.Types.TypeProto();
                }
                input.ReadMessage(valueType_);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// A type reference represents an alias for a typed declared in the 'types' section of a
      /// model document.
      /// </summary>
      public sealed partial class TypeReferenceProto : pb::IMessage<TypeReferenceProto> {
        private static readonly pb::MessageParser<TypeReferenceProto> _parser = new pb::MessageParser<TypeReferenceProto>(() => new TypeReferenceProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TypeReferenceProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[8]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TypeReferenceProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TypeReferenceProto(TypeReferenceProto other) : this() {
          reference_ = other.reference_;
          typeBindings_ = other.typeBindings_.Clone();
          shapeBindings_ = other.shapeBindings_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TypeReferenceProto Clone() {
          return new TypeReferenceProto(this);
        }

        /// <summary>Field number for the "reference" field.</summary>
        public const int ReferenceFieldNumber = 1;
        private string reference_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Reference {
          get { return reference_; }
          set {
            reference_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "type_bindings" field.</summary>
        public const int TypeBindingsFieldNumber = 2;
        private static readonly pbc::MapField<string, string>.Codec _map_typeBindings_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 18);
        private readonly pbc::MapField<string, string> typeBindings_ = new pbc::MapField<string, string>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, string> TypeBindings {
          get { return typeBindings_; }
        }

        /// <summary>Field number for the "shape_bindings" field.</summary>
        public const int ShapeBindingsFieldNumber = 3;
        private static readonly pbc::MapField<string, ulong>.Codec _map_shapeBindings_codec
            = new pbc::MapField<string, ulong>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForUInt64(16), 26);
        private readonly pbc::MapField<string, ulong> shapeBindings_ = new pbc::MapField<string, ulong>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, ulong> ShapeBindings {
          get { return shapeBindings_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TypeReferenceProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TypeReferenceProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Reference != other.Reference) return false;
          if (!TypeBindings.Equals(other.TypeBindings)) return false;
          if (!ShapeBindings.Equals(other.ShapeBindings)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Reference.Length != 0) hash ^= Reference.GetHashCode();
          hash ^= TypeBindings.GetHashCode();
          hash ^= ShapeBindings.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Reference.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Reference);
          }
          typeBindings_.WriteTo(output, _map_typeBindings_codec);
          shapeBindings_.WriteTo(output, _map_shapeBindings_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Reference.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Reference);
          }
          size += typeBindings_.CalculateSize(_map_typeBindings_codec);
          size += shapeBindings_.CalculateSize(_map_shapeBindings_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TypeReferenceProto other) {
          if (other == null) {
            return;
          }
          if (other.Reference.Length != 0) {
            Reference = other.Reference;
          }
          typeBindings_.Add(other.typeBindings_);
          shapeBindings_.Add(other.shapeBindings_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Reference = input.ReadString();
                break;
              }
              case 18: {
                typeBindings_.AddEntriesFrom(input, _map_typeBindings_codec);
                break;
              }
              case 26: {
                shapeBindings_.AddEntriesFrom(input, _map_shapeBindings_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// A type parameter is used in intrinsic function declarations, denoting a type name that can be
      /// bound to other types at a function call site.
      /// </summary>
      public sealed partial class TypeParameterProto : pb::IMessage<TypeParameterProto> {
        private static readonly pb::MessageParser<TypeParameterProto> _parser = new pb::MessageParser<TypeParameterProto>(() => new TypeParameterProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TypeParameterProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[9]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TypeParameterProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TypeParameterProto(TypeParameterProto other) : this() {
          parameter_ = other.parameter_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TypeParameterProto Clone() {
          return new TypeParameterProto(this);
        }

        /// <summary>Field number for the "parameter" field.</summary>
        public const int ParameterFieldNumber = 1;
        private string parameter_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Parameter {
          get { return parameter_; }
          set {
            parameter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TypeParameterProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TypeParameterProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Parameter != other.Parameter) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Parameter.Length != 0) hash ^= Parameter.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Parameter.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Parameter);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Parameter.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Parameter);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TypeParameterProto other) {
          if (other == null) {
            return;
          }
          if (other.Parameter.Length != 0) {
            Parameter = other.Parameter;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Parameter = input.ReadString();
                break;
              }
            }
          }
        }

      }

      public sealed partial class ParameterDeclProto : pb::IMessage<ParameterDeclProto> {
        private static readonly pb::MessageParser<ParameterDeclProto> _parser = new pb::MessageParser<ParameterDeclProto>(() => new ParameterDeclProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ParameterDeclProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[10]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ParameterDeclProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ParameterDeclProto(ParameterDeclProto other) : this() {
          name_ = other.name_;
          Type = other.type_ != null ? other.Type.Clone() : null;
          docString_ = other.docString_;
          variadic_ = other.variadic_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ParameterDeclProto Clone() {
          return new ParameterDeclProto(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 2;
        private global::LotusvNext.Types.TypeProto type_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusvNext.Types.TypeProto Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "doc_string" field.</summary>
        public const int DocStringFieldNumber = 3;
        private string docString_ = "";
        /// <summary>
        /// An  human-readable documentation for this parameter.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string DocString {
          get { return docString_; }
          set {
            docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "variadic" field.</summary>
        public const int VariadicFieldNumber = 100;
        private bool variadic_;
        /// <summary>
        /// Indicates whether this parameter can take a list of values.
        /// Only applicable to input parameters.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Variadic {
          get { return variadic_; }
          set {
            variadic_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ParameterDeclProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ParameterDeclProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(Type, other.Type)) return false;
          if (DocString != other.DocString) return false;
          if (Variadic != other.Variadic) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (type_ != null) hash ^= Type.GetHashCode();
          if (DocString.Length != 0) hash ^= DocString.GetHashCode();
          if (Variadic != false) hash ^= Variadic.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (type_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Type);
          }
          if (DocString.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(DocString);
          }
          if (Variadic != false) {
            output.WriteRawTag(160, 6);
            output.WriteBool(Variadic);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (type_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Type);
          }
          if (DocString.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
          }
          if (Variadic != false) {
            size += 2 + 1;
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ParameterDeclProto other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.type_ != null) {
            if (type_ == null) {
              type_ = new global::LotusvNext.Types.TypeProto();
            }
            Type.MergeFrom(other.Type);
          }
          if (other.DocString.Length != 0) {
            DocString = other.DocString;
          }
          if (other.Variadic != false) {
            Variadic = other.Variadic;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (type_ == null) {
                  type_ = new global::LotusvNext.Types.TypeProto();
                }
                input.ReadMessage(type_);
                break;
              }
              case 26: {
                DocString = input.ReadString();
                break;
              }
              case 800: {
                Variadic = input.ReadBool();
                break;
              }
            }
          }
        }

      }

      public sealed partial class SignatureDeclProto : pb::IMessage<SignatureDeclProto> {
        private static readonly pb::MessageParser<SignatureDeclProto> _parser = new pb::MessageParser<SignatureDeclProto>(() => new SignatureDeclProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SignatureDeclProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Types.TypeProto.Descriptor.NestedTypes[11]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SignatureDeclProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SignatureDeclProto(SignatureDeclProto other) : this() {
          inputParams_ = other.inputParams_.Clone();
          outputParams_ = other.outputParams_.Clone();
          inputAttributes_ = other.inputAttributes_.Clone();
          docString_ = other.docString_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SignatureDeclProto Clone() {
          return new SignatureDeclProto(this);
        }

        /// <summary>Field number for the "input_params" field.</summary>
        public const int InputParamsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> _repeated_inputParams_codec
            = pb::FieldCodec.ForMessage(10, global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto.Parser);
        private readonly pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> inputParams_ = new pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto>();
        /// <summary>
        /// The formal input parameters to the operation or function 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> InputParams {
          get { return inputParams_; }
        }

        /// <summary>Field number for the "output_params" field.</summary>
        public const int OutputParamsFieldNumber = 2;
        private static readonly pb::FieldCodec<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> _repeated_outputParams_codec
            = pb::FieldCodec.ForMessage(18, global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto.Parser);
        private readonly pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> outputParams_ = new pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto>();
        /// <summary>
        /// The formal output parameters to the operation or function 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> OutputParams {
          get { return outputParams_; }
        }

        /// <summary>Field number for the "input_attributes" field.</summary>
        public const int InputAttributesFieldNumber = 3;
        private static readonly pb::FieldCodec<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> _repeated_inputAttributes_codec
            = pb::FieldCodec.ForMessage(26, global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto.Parser);
        private readonly pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> inputAttributes_ = new pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto>();
        /// <summary>
        /// The declaration of expected attributes to the operation or function 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> InputAttributes {
          get { return inputAttributes_; }
        }

        /// <summary>Field number for the "doc_string" field.</summary>
        public const int DocStringFieldNumber = 4;
        private string docString_ = "";
        /// <summary>
        /// An  human-readable documentation for this signature.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string DocString {
          get { return docString_; }
          set {
            docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SignatureDeclProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SignatureDeclProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!inputParams_.Equals(other.inputParams_)) return false;
          if(!outputParams_.Equals(other.outputParams_)) return false;
          if(!inputAttributes_.Equals(other.inputAttributes_)) return false;
          if (DocString != other.DocString) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= inputParams_.GetHashCode();
          hash ^= outputParams_.GetHashCode();
          hash ^= inputAttributes_.GetHashCode();
          if (DocString.Length != 0) hash ^= DocString.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          inputParams_.WriteTo(output, _repeated_inputParams_codec);
          outputParams_.WriteTo(output, _repeated_outputParams_codec);
          inputAttributes_.WriteTo(output, _repeated_inputAttributes_codec);
          if (DocString.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(DocString);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += inputParams_.CalculateSize(_repeated_inputParams_codec);
          size += outputParams_.CalculateSize(_repeated_outputParams_codec);
          size += inputAttributes_.CalculateSize(_repeated_inputAttributes_codec);
          if (DocString.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SignatureDeclProto other) {
          if (other == null) {
            return;
          }
          inputParams_.Add(other.inputParams_);
          outputParams_.Add(other.outputParams_);
          inputAttributes_.Add(other.inputAttributes_);
          if (other.DocString.Length != 0) {
            DocString = other.DocString;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                inputParams_.AddEntriesFrom(input, _repeated_inputParams_codec);
                break;
              }
              case 18: {
                outputParams_.AddEntriesFrom(input, _repeated_outputParams_codec);
                break;
              }
              case 26: {
                inputAttributes_.AddEntriesFrom(input, _repeated_inputAttributes_codec);
                break;
              }
              case 34: {
                DocString = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
