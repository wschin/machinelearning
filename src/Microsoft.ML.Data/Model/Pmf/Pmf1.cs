// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pmf1.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace LotusvNext {

  /// <summary>Holder for reflection information generated from pmf1.proto</summary>
  public static partial class Pmf1Reflection {

    #region Descriptor
    /// <summary>File descriptor for pmf1.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static Pmf1Reflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgpwbWYxLnByb3RvEgpMb3R1c3ZOZXh0Gg5vbm54LW1sLnByb3RvMxoLdHlw",
            "ZXMucHJvdG8aEWV4cHJlc3Npb25zLnByb3RvIuUDCgpNb2RlbFByb3RvEhIK",
            "CmlyX3ZlcnNpb24YASABKAMSNAoMb3BzZXRfaW1wb3J0GAggAygLMh4uTG90",
            "dXN2TmV4dC5PcGVyYXRvclNldElkUHJvdG8SFQoNcHJvZHVjZXJfbmFtZRgC",
            "IAEoCRIYChBwcm9kdWNlcl92ZXJzaW9uGAMgASgJEg4KBmRvbWFpbhgEIAEo",
            "CRIVCg1tb2RlbF92ZXJzaW9uGAUgASgDEhIKCmRvY19zdHJpbmcYBiABKAkS",
            "JQoFZ3JhcGgYByABKAsyFi5Mb3R1c3ZOZXh0LkdyYXBoUHJvdG8SOgoObWV0",
            "YWRhdGFfcHJvcHMYDiADKAsyIi5Mb3R1c3ZOZXh0LlN0cmluZ1N0cmluZ0Vu",
            "dHJ5UHJvdG8SLwoFbW9kZWwYZCABKAsyIC5Mb3R1c3ZOZXh0LkZ1bmN0aW9u",
            "YWxNb2RlbFByb3RvEg8KB3Byb2ZpbGUYZSABKAkSMAoFdHlwZXMYZiADKAsy",
            "IS5Mb3R1c3ZOZXh0Lk1vZGVsUHJvdG8uVHlwZXNFbnRyeRpDCgpUeXBlc0Vu",
            "dHJ5EgsKA2tleRgBIAEoCRIkCgV2YWx1ZRgCIAEoCzIVLkxvdHVzdk5leHQu",
            "VHlwZVByb3RvOgI4AUoFCG4QyQEiNAoWU3RyaW5nU3RyaW5nRW50cnlQcm90",
            "bxILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAkiswIKCkdyYXBoUHJvdG8S",
            "HQoEbm9kZRgBIAMoCzIPLm9ubnguTm9kZVByb3RvEgwKBG5hbWUYAiABKAkS",
            "JgoLaW5pdGlhbGl6ZXIYBSADKAsyES5vbm54LlRlbnNvclByb3RvEhIKCmRv",
            "Y19zdHJpbmcYCiABKAkSKQoFaW5wdXQYCyADKAsyGi5Mb3R1c3ZOZXh0LlZh",
            "bHVlSW5mb1Byb3RvEioKBm91dHB1dBgMIAMoCzIaLkxvdHVzdk5leHQuVmFs",
            "dWVJbmZvUHJvdG8SLgoKdmFsdWVfaW5mbxgNIAMoCzIaLkxvdHVzdk5leHQu",
            "VmFsdWVJbmZvUHJvdG8SLgoIZnVuY3Rpb24YMiADKAsyHC5Mb3R1c3ZOZXh0",
            "LkZ1bmN0aW9uRGVmUHJvdG9KBQhkEMkBIrkEChRGdW5jdGlvbmFsTW9kZWxQ",
            "cm90bxIMCgRuYW1lGAEgASgJEjsKCXNpZ25hdHVyZRgCIAEoCzIoLkxvdHVz",
            "dk5leHQuVHlwZVByb3RvLlNpZ25hdHVyZURlY2xQcm90bxI6CgV0eXBlcxgD",
            "IAMoCzIrLkxvdHVzdk5leHQuRnVuY3Rpb25hbE1vZGVsUHJvdG8uVHlwZXNF",
            "bnRyeRJCCglmdW5jdGlvbnMYBCADKAsyLy5Mb3R1c3ZOZXh0LkZ1bmN0aW9u",
            "YWxNb2RlbFByb3RvLkZ1bmN0aW9uc0VudHJ5EhAKCGluY2x1ZGVzGAUgAygJ",
            "EiQKBGJvZHkYBiADKAsyFi5Mb3R1c3ZOZXh0LkV4cHJlc3Npb24SOgoFY2Vs",
            "bHMYByADKAsyKy5Mb3R1c3ZOZXh0LkZ1bmN0aW9uYWxNb2RlbFByb3RvLkNl",
            "bGxzRW50cnkaQwoKVHlwZXNFbnRyeRILCgNrZXkYASABKAkSJAoFdmFsdWUY",
            "AiABKAsyFS5Mb3R1c3ZOZXh0LlR5cGVQcm90bzoCOAEaTgoORnVuY3Rpb25z",
            "RW50cnkSCwoDa2V5GAEgASgJEisKBXZhbHVlGAIgASgLMhwuTG90dXN2TmV4",
            "dC5GdW5jdGlvbkRlZlByb3RvOgI4ARpGCgpDZWxsc0VudHJ5EgsKA2tleRgB",
            "IAEoCRInCgV2YWx1ZRgCIAEoCzIYLkxvdHVzdk5leHQuTGlicmFyeS5DZWxs",
            "OgI4AUoFCGQQyQEi6QIKEEZ1bmN0aW9uRGVmUHJvdG8SDAoEbmFtZRgBIAEo",
            "CRI+CgxpbnB1dF9wYXJhbXMYAiADKAsyKC5Mb3R1c3ZOZXh0LlR5cGVQcm90",
            "by5QYXJhbWV0ZXJEZWNsUHJvdG8SPwoNb3V0cHV0X3BhcmFtcxgDIAMoCzIo",
            "LkxvdHVzdk5leHQuVHlwZVByb3RvLlBhcmFtZXRlckRlY2xQcm90bxIdCgRu",
            "b2RlGAQgAygLMg8ub25ueC5Ob2RlUHJvdG8SIgoEYXR0chgFIAMoCzIULm9u",
            "bnguQXR0cmlidXRlUHJvdG8SEgoKZG9jX3N0cmluZxgGIAEoCRIkCgRib2R5",
            "GGUgAygLMhYuTG90dXN2TmV4dC5FeHByZXNzaW9uEkIKEGlucHV0X2F0dHJp",
            "YnV0ZXMYZyADKAsyKC5Mb3R1c3ZOZXh0LlR5cGVQcm90by5QYXJhbWV0ZXJE",
            "ZWNsUHJvdG9KBQhuEMkBIosBChFPcGVyYXRvckRlY2xQcm90bxIMCgRuYW1l",
            "GAEgASgJEjsKCXNpZ25hdHVyZRgCIAMoCzIoLkxvdHVzdk5leHQuVHlwZVBy",
            "b3RvLlNpZ25hdHVyZURlY2xQcm90bxISCgpkb2Nfc3RyaW5nGAMgASgJEhAK",
            "CHN1ZmZpeGVzGGUgAygJSgUIbhDJASKNBgoHTGlicmFyeRISCgppcl92ZXJz",
            "aW9uGAEgASgDEhgKEHByb2R1Y2VyX3ZlcnNpb24YAiABKAMSFAoMcHJvZHVj",
            "ZXJfdGFnGAMgASgJEhUKDW1vZGVsX3ZlcnNpb24YBCABKAMSFAoMbW9kZWxf",
            "YXV0aG9yGAUgASgJEhUKDW1vZGVsX2xpY2Vuc2UYBiABKAkSDAoEbmFtZRgH",
            "IAEoCRIOCgZkb21haW4YCCABKAkSEgoKZG9jX3N0cmluZxgJIAEoCRIvCghv",
            "cGVyYXRvchgKIAMoCzIdLkxvdHVzdk5leHQuT3BlcmF0b3JEZWNsUHJvdG8S",
            "LgoIZnVuY3Rpb24YCyADKAsyHC5Mb3R1c3ZOZXh0LkZ1bmN0aW9uRGVmUHJv",
            "dG8SGgoSaW1wb3J0ZWRfbGlicmFyaWVzGAwgAygJEjMKCG1ldGFkYXRhGGQg",
            "AygLMiEuTG90dXN2TmV4dC5MaWJyYXJ5Lk1ldGFkYXRhRW50cnkSLQoFdHlw",
            "ZXMYZSADKAsyHi5Mb3R1c3ZOZXh0LkxpYnJhcnkuVHlwZXNFbnRyeRIQCghl",
            "eGNsdWRlZBhmIAMoCRItCgVjZWxscxhnIAMoCzIeLkxvdHVzdk5leHQuTGli",
            "cmFyeS5DZWxsc0VudHJ5GmEKBENlbGwSDgoGc291cmNlGAEgASgJEiMKBHR5",
            "cGUYAiABKAsyFS5Mb3R1c3ZOZXh0LlR5cGVQcm90bxIkCgRpbml0GAMgASgL",
            "MhYuTG90dXN2TmV4dC5WYWx1ZVByb3RvGi8KDU1ldGFkYXRhRW50cnkSCwoD",
            "a2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ARpDCgpUeXBlc0VudHJ5EgsK",
            "A2tleRgBIAEoCRIkCgV2YWx1ZRgCIAEoCzIVLkxvdHVzdk5leHQuVHlwZVBy",
            "b3RvOgI4ARpGCgpDZWxsc0VudHJ5EgsKA2tleRgBIAEoCRInCgV2YWx1ZRgC",
            "IAEoCzIYLkxvdHVzdk5leHQuTGlicmFyeS5DZWxsOgI4AUoFCG4QyQEiNQoS",
            "T3BlcmF0b3JTZXRJZFByb3RvEg4KBmRvbWFpbhgBIAEoCRIPCgd2ZXJzaW9u",
            "GAIgASgDKnkKB1ZlcnNpb24SEgoOX1NUQVJUX1ZFUlNJT04QABIZChVJUl9W",
            "RVJTSU9OXzIwMTdfMTBfMTAQARIZChVJUl9WRVJTSU9OXzIwMTdfMTBfMzAQ",
            "AhITCg9JUl9WRVJTSU9OX09OTlgQAxIPCgtJUl9WRVJTSU9OXxAEQg2qAgpM",
            "b3R1c3ZOZXh0YgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::ONNX.OnnxMlReflection.Descriptor, global::LotusvNext.Types.TypesReflection.Descriptor, global::LotusvNext.Expressions.ExpressionsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::LotusvNext.Version), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.ModelProto), global::LotusvNext.ModelProto.Parser, new[]{ "IrVersion", "OpsetImport", "ProducerName", "ProducerVersion", "Domain", "ModelVersion", "DocString", "Graph", "MetadataProps", "Model", "Profile", "Types_" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.StringStringEntryProto), global::LotusvNext.StringStringEntryProto.Parser, new[]{ "Key", "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.GraphProto), global::LotusvNext.GraphProto.Parser, new[]{ "Node", "Name", "Initializer", "DocString", "Input", "Output", "ValueInfo", "Function" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.FunctionalModelProto), global::LotusvNext.FunctionalModelProto.Parser, new[]{ "Name", "Signature", "Types_", "Functions", "Includes", "Body", "Cells" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.FunctionDefProto), global::LotusvNext.FunctionDefProto.Parser, new[]{ "Name", "InputParams", "OutputParams", "Node", "Attr", "DocString", "Body", "InputAttributes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.OperatorDeclProto), global::LotusvNext.OperatorDeclProto.Parser, new[]{ "Name", "Signature", "DocString", "Suffixes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Library), global::LotusvNext.Library.Parser, new[]{ "IrVersion", "ProducerVersion", "ProducerTag", "ModelVersion", "ModelAuthor", "ModelLicense", "Name", "Domain", "DocString", "Operator", "Function", "ImportedLibraries", "Metadata", "Types_", "Excluded", "Cells" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.Library.Types.Cell), global::LotusvNext.Library.Types.Cell.Parser, new[]{ "Source", "Type", "Init" }, null, null, null),
            null, null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusvNext.OperatorSetIdProto), global::LotusvNext.OperatorSetIdProto.Parser, new[]{ "Domain", "Version" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  public enum Version {
    /// <summary>
    /// proto3 requires the first enum value to be zero.
    /// We add this just to appease the compiler.
    /// </summary>
    [pbr::OriginalName("_START_VERSION")] StartVersion = 0,
    /// <summary>
    /// The version field is always serialized and we will use it to store the
    /// version that the  graph is generated from. This helps us set up version
    /// control. We should use version as
    ///     xx(major) - xx(minor) - xxxx(bugfix)
    /// and we are starting with 0x00000001 (0.0.1), which was the
    ///  version we published on Oct 10, 2017.
    /// </summary>
    [pbr::OriginalName("IR_VERSION_2017_10_10")] IrVersion20171010 = 1,
    /// <summary>
    /// IR_VERSION 0.0.2 published on Oct 30, 2017
    /// - Added type discriminator to AttributeProto to support proto3 users
    /// </summary>
    [pbr::OriginalName("IR_VERSION_2017_10_30")] IrVersion20171030 = 2,
    /// <summary>
    /// IR VERSION 0.0.3 published on Nov 3, 2017
    /// - For operator versioning:
    ///    - Added new message OperatorSetIdProto
    ///    - Added opset_import in ModelProto
    /// - For vendor extensions, added domain in NodeProto
    /// </summary>
    [pbr::OriginalName("IR_VERSION_ONNX")] IrVersionOnnx = 3,
    /// <summary>
    /// PMF, experimental
    /// </summary>
    [pbr::OriginalName("IR_VERSION_")] IrVersion = 4,
  }

  #endregion

  #region Messages
  /// <summary>
  /// ModelProto is a top-level file/container format for bundling a ML model.
  /// The semantics of the model are described by the GraphProto that represents
  /// a parameterized computation graph against a set of named operators that are
  /// defined independently from the graph.
  /// </summary>
  public sealed partial class ModelProto : pb::IMessage<ModelProto> {
    private static readonly pb::MessageParser<ModelProto> _parser = new pb::MessageParser<ModelProto>(() => new ModelProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusvNext.Pmf1Reflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelProto(ModelProto other) : this() {
      irVersion_ = other.irVersion_;
      opsetImport_ = other.opsetImport_.Clone();
      producerName_ = other.producerName_;
      producerVersion_ = other.producerVersion_;
      domain_ = other.domain_;
      modelVersion_ = other.modelVersion_;
      docString_ = other.docString_;
      Graph = other.graph_ != null ? other.Graph.Clone() : null;
      metadataProps_ = other.metadataProps_.Clone();
      Model = other.model_ != null ? other.Model.Clone() : null;
      profile_ = other.profile_;
      types_ = other.types_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelProto Clone() {
      return new ModelProto(this);
    }

    /// <summary>Field number for the "ir_version" field.</summary>
    public const int IrVersionFieldNumber = 1;
    private long irVersion_;
    /// <summary>
    /// The version of the IR this model targets. See Version enum above.
    /// This field MUST be present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IrVersion {
      get { return irVersion_; }
      set {
        irVersion_ = value;
      }
    }

    /// <summary>Field number for the "opset_import" field.</summary>
    public const int OpsetImportFieldNumber = 8;
    private static readonly pb::FieldCodec<global::LotusvNext.OperatorSetIdProto> _repeated_opsetImport_codec
        = pb::FieldCodec.ForMessage(66, global::LotusvNext.OperatorSetIdProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.OperatorSetIdProto> opsetImport_ = new pbc::RepeatedField<global::LotusvNext.OperatorSetIdProto>();
    /// <summary>
    /// The OperatorSets this model relies on.
    /// All ModelProtos MUST have at least one entry that
    /// specifies which version of the ONNX OperatorSet is
    /// being imported.
    ///
    /// All nodes in the ModelProto's graph will bind against the operator
    /// with the same-domain/same-op_type operator with the HIGHEST version
    /// in the referenced operator sets.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.OperatorSetIdProto> OpsetImport {
      get { return opsetImport_; }
    }

    /// <summary>Field number for the "producer_name" field.</summary>
    public const int ProducerNameFieldNumber = 2;
    private string producerName_ = "";
    /// <summary>
    /// The name of the framework or tool used to generate this model.
    /// This field SHOULD be present to indicate which implementation/tool/framework
    /// emitted the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProducerName {
      get { return producerName_; }
      set {
        producerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "producer_version" field.</summary>
    public const int ProducerVersionFieldNumber = 3;
    private string producerVersion_ = "";
    /// <summary>
    /// The version of the framework or tool used to generate this model.
    /// This field SHOULD be present to indicate which implementation/tool/framework
    /// emitted the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProducerVersion {
      get { return producerVersion_; }
      set {
        producerVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "domain" field.</summary>
    public const int DomainFieldNumber = 4;
    private string domain_ = "";
    /// <summary>
    /// Domain name of the model.
    /// We use reverse domain names as name space indicators. For example:
    /// `com.facebook.fair` or `com.microsoft.cognitiveservices`
    ///
    /// Together with `model_version` and GraphProto.name, this forms the unique identity of
    /// the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Domain {
      get { return domain_; }
      set {
        domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_version" field.</summary>
    public const int ModelVersionFieldNumber = 5;
    private long modelVersion_;
    /// <summary>
    /// The version of the graph encoded. See Version enum below.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ModelVersion {
      get { return modelVersion_; }
      set {
        modelVersion_ = value;
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 6;
    private string docString_ = "";
    /// <summary>
    /// A human-readable documentation for this model. Markdown is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "graph" field.</summary>
    public const int GraphFieldNumber = 7;
    private global::LotusvNext.GraphProto graph_;
    /// <summary>
    /// The parameterized graph that is evaluated to execute the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.GraphProto Graph {
      get { return graph_; }
      set {
        graph_ = value;
      }
    }

    /// <summary>Field number for the "metadata_props" field.</summary>
    public const int MetadataPropsFieldNumber = 14;
    private static readonly pb::FieldCodec<global::LotusvNext.StringStringEntryProto> _repeated_metadataProps_codec
        = pb::FieldCodec.ForMessage(114, global::LotusvNext.StringStringEntryProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.StringStringEntryProto> metadataProps_ = new pbc::RepeatedField<global::LotusvNext.StringStringEntryProto>();
    /// <summary>
    /// Named metadata values; keys should be distinct.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.StringStringEntryProto> MetadataProps {
      get { return metadataProps_; }
    }

    /// <summary>Field number for the "model" field.</summary>
    public const int ModelFieldNumber = 100;
    private global::LotusvNext.FunctionalModelProto model_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.FunctionalModelProto Model {
      get { return model_; }
      set {
        model_ = value;
      }
    }

    /// <summary>Field number for the "profile" field.</summary>
    public const int ProfileFieldNumber = 101;
    private string profile_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Profile {
      get { return profile_; }
      set {
        profile_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "types" field.</summary>
    public const int Types_FieldNumber = 102;
    private static readonly pbc::MapField<string, global::LotusvNext.Types.TypeProto>.Codec _map_types_codec
        = new pbc::MapField<string, global::LotusvNext.Types.TypeProto>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::LotusvNext.Types.TypeProto.Parser), 818);
    private readonly pbc::MapField<string, global::LotusvNext.Types.TypeProto> types_ = new pbc::MapField<string, global::LotusvNext.Types.TypeProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::LotusvNext.Types.TypeProto> Types_ {
      get { return types_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IrVersion != other.IrVersion) return false;
      if(!opsetImport_.Equals(other.opsetImport_)) return false;
      if (ProducerName != other.ProducerName) return false;
      if (ProducerVersion != other.ProducerVersion) return false;
      if (Domain != other.Domain) return false;
      if (ModelVersion != other.ModelVersion) return false;
      if (DocString != other.DocString) return false;
      if (!object.Equals(Graph, other.Graph)) return false;
      if(!metadataProps_.Equals(other.metadataProps_)) return false;
      if (!object.Equals(Model, other.Model)) return false;
      if (Profile != other.Profile) return false;
      if (!Types_.Equals(other.Types_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (IrVersion != 0L) hash ^= IrVersion.GetHashCode();
      hash ^= opsetImport_.GetHashCode();
      if (ProducerName.Length != 0) hash ^= ProducerName.GetHashCode();
      if (ProducerVersion.Length != 0) hash ^= ProducerVersion.GetHashCode();
      if (Domain.Length != 0) hash ^= Domain.GetHashCode();
      if (ModelVersion != 0L) hash ^= ModelVersion.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      if (graph_ != null) hash ^= Graph.GetHashCode();
      hash ^= metadataProps_.GetHashCode();
      if (model_ != null) hash ^= Model.GetHashCode();
      if (Profile.Length != 0) hash ^= Profile.GetHashCode();
      hash ^= Types_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (IrVersion != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(IrVersion);
      }
      if (ProducerName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProducerName);
      }
      if (ProducerVersion.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ProducerVersion);
      }
      if (Domain.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Domain);
      }
      if (ModelVersion != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(ModelVersion);
      }
      if (DocString.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(DocString);
      }
      if (graph_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Graph);
      }
      opsetImport_.WriteTo(output, _repeated_opsetImport_codec);
      metadataProps_.WriteTo(output, _repeated_metadataProps_codec);
      if (model_ != null) {
        output.WriteRawTag(162, 6);
        output.WriteMessage(Model);
      }
      if (Profile.Length != 0) {
        output.WriteRawTag(170, 6);
        output.WriteString(Profile);
      }
      types_.WriteTo(output, _map_types_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (IrVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IrVersion);
      }
      size += opsetImport_.CalculateSize(_repeated_opsetImport_codec);
      if (ProducerName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProducerName);
      }
      if (ProducerVersion.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProducerVersion);
      }
      if (Domain.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
      }
      if (ModelVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ModelVersion);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      if (graph_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Graph);
      }
      size += metadataProps_.CalculateSize(_repeated_metadataProps_codec);
      if (model_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Model);
      }
      if (Profile.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Profile);
      }
      size += types_.CalculateSize(_map_types_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelProto other) {
      if (other == null) {
        return;
      }
      if (other.IrVersion != 0L) {
        IrVersion = other.IrVersion;
      }
      opsetImport_.Add(other.opsetImport_);
      if (other.ProducerName.Length != 0) {
        ProducerName = other.ProducerName;
      }
      if (other.ProducerVersion.Length != 0) {
        ProducerVersion = other.ProducerVersion;
      }
      if (other.Domain.Length != 0) {
        Domain = other.Domain;
      }
      if (other.ModelVersion != 0L) {
        ModelVersion = other.ModelVersion;
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      if (other.graph_ != null) {
        if (graph_ == null) {
          graph_ = new global::LotusvNext.GraphProto();
        }
        Graph.MergeFrom(other.Graph);
      }
      metadataProps_.Add(other.metadataProps_);
      if (other.model_ != null) {
        if (model_ == null) {
          model_ = new global::LotusvNext.FunctionalModelProto();
        }
        Model.MergeFrom(other.Model);
      }
      if (other.Profile.Length != 0) {
        Profile = other.Profile;
      }
      types_.Add(other.types_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            IrVersion = input.ReadInt64();
            break;
          }
          case 18: {
            ProducerName = input.ReadString();
            break;
          }
          case 26: {
            ProducerVersion = input.ReadString();
            break;
          }
          case 34: {
            Domain = input.ReadString();
            break;
          }
          case 40: {
            ModelVersion = input.ReadInt64();
            break;
          }
          case 50: {
            DocString = input.ReadString();
            break;
          }
          case 58: {
            if (graph_ == null) {
              graph_ = new global::LotusvNext.GraphProto();
            }
            input.ReadMessage(graph_);
            break;
          }
          case 66: {
            opsetImport_.AddEntriesFrom(input, _repeated_opsetImport_codec);
            break;
          }
          case 114: {
            metadataProps_.AddEntriesFrom(input, _repeated_metadataProps_codec);
            break;
          }
          case 802: {
            if (model_ == null) {
              model_ = new global::LotusvNext.FunctionalModelProto();
            }
            input.ReadMessage(model_);
            break;
          }
          case 810: {
            Profile = input.ReadString();
            break;
          }
          case 818: {
            types_.AddEntriesFrom(input, _map_types_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// StringStringEntryProto follows the pattern for cross-proto-version maps.
  /// See https://developers.google.com/protocol-buffers/docs/proto3#maps
  /// </summary>
  public sealed partial class StringStringEntryProto : pb::IMessage<StringStringEntryProto> {
    private static readonly pb::MessageParser<StringStringEntryProto> _parser = new pb::MessageParser<StringStringEntryProto>(() => new StringStringEntryProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StringStringEntryProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusvNext.Pmf1Reflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StringStringEntryProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StringStringEntryProto(StringStringEntryProto other) : this() {
      key_ = other.key_;
      value_ = other.value_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StringStringEntryProto Clone() {
      return new StringStringEntryProto(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private string key_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Key {
      get { return key_; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private string value_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StringStringEntryProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StringStringEntryProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Value != other.Value) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Key.Length != 0) hash ^= Key.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Key.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Key.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StringStringEntryProto other) {
      if (other == null) {
        return;
      }
      if (other.Key.Length != 0) {
        Key = other.Key;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// GraphProto defines a parameterized series of nodes to form a directed acyclic graph.
  /// This is the equivalent of the "network" and "graph" in many deep learning
  /// frameworks.
  /// All the input/output tensors are explicitly named so a framework can
  /// run any subgraph of the graph by feeding and fetching the named tensors.
  /// </summary>
  public sealed partial class GraphProto : pb::IMessage<GraphProto> {
    private static readonly pb::MessageParser<GraphProto> _parser = new pb::MessageParser<GraphProto>(() => new GraphProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GraphProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusvNext.Pmf1Reflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraphProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraphProto(GraphProto other) : this() {
      node_ = other.node_.Clone();
      name_ = other.name_;
      initializer_ = other.initializer_.Clone();
      docString_ = other.docString_;
      input_ = other.input_.Clone();
      output_ = other.output_.Clone();
      valueInfo_ = other.valueInfo_.Clone();
      function_ = other.function_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraphProto Clone() {
      return new GraphProto(this);
    }

    /// <summary>Field number for the "node" field.</summary>
    public const int NodeFieldNumber = 1;
    private static readonly pb::FieldCodec<global::ONNX.NodeProto> _repeated_node_codec
        = pb::FieldCodec.ForMessage(10, global::ONNX.NodeProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.NodeProto> node_ = new pbc::RepeatedField<global::ONNX.NodeProto>();
    /// <summary>
    /// The nodes in the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.NodeProto> Node {
      get { return node_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// The name of the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "initializer" field.</summary>
    public const int InitializerFieldNumber = 5;
    private static readonly pb::FieldCodec<global::ONNX.TensorProto> _repeated_initializer_codec
        = pb::FieldCodec.ForMessage(42, global::ONNX.TensorProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.TensorProto> initializer_ = new pbc::RepeatedField<global::ONNX.TensorProto>();
    /// <summary>
    /// A list of named tensor values (constants), used to specify default
    /// values for some of the inputs of the graph.
    /// Each TensorProto entry must have a distinct name (within the list) that
    /// also appears in the input list.
    /// In an evaluation, the default value specified here is used if and only if
    /// user specifies no value for the corresponding input parameter.
    /// May be used to pass serialized parameters for networks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.TensorProto> Initializer {
      get { return initializer_; }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 10;
    private string docString_ = "";
    /// <summary>
    /// A human-readable documentation for this graph. Markdown is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "input" field.</summary>
    public const int InputFieldNumber = 11;
    private static readonly pb::FieldCodec<global::LotusvNext.Types.ValueInfoProto> _repeated_input_codec
        = pb::FieldCodec.ForMessage(90, global::LotusvNext.Types.ValueInfoProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto> input_ = new pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto>();
    /// <summary>
    /// The inputs and outputs of the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto> Input {
      get { return input_; }
    }

    /// <summary>Field number for the "output" field.</summary>
    public const int OutputFieldNumber = 12;
    private static readonly pb::FieldCodec<global::LotusvNext.Types.ValueInfoProto> _repeated_output_codec
        = pb::FieldCodec.ForMessage(98, global::LotusvNext.Types.ValueInfoProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto> output_ = new pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto> Output {
      get { return output_; }
    }

    /// <summary>Field number for the "value_info" field.</summary>
    public const int ValueInfoFieldNumber = 13;
    private static readonly pb::FieldCodec<global::LotusvNext.Types.ValueInfoProto> _repeated_valueInfo_codec
        = pb::FieldCodec.ForMessage(106, global::LotusvNext.Types.ValueInfoProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto> valueInfo_ = new pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto>();
    /// <summary>
    /// Information for the values in the graph. The ValueInfoProto.name's
    /// must be distinct. It is for a value to appear in value_info list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.Types.ValueInfoProto> ValueInfo {
      get { return valueInfo_; }
    }

    /// <summary>Field number for the "function" field.</summary>
    public const int FunctionFieldNumber = 50;
    private static readonly pb::FieldCodec<global::LotusvNext.FunctionDefProto> _repeated_function_codec
        = pb::FieldCodec.ForMessage(402, global::LotusvNext.FunctionDefProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.FunctionDefProto> function_ = new pbc::RepeatedField<global::LotusvNext.FunctionDefProto>();
    /// <summary>
    /// The function definitions of the graph. They can only only be used
    /// (i.e., called) in this graph.
    /// Each FunctionDefProto in function MUST have a unique name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.FunctionDefProto> Function {
      get { return function_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GraphProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GraphProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!node_.Equals(other.node_)) return false;
      if (Name != other.Name) return false;
      if(!initializer_.Equals(other.initializer_)) return false;
      if (DocString != other.DocString) return false;
      if(!input_.Equals(other.input_)) return false;
      if(!output_.Equals(other.output_)) return false;
      if(!valueInfo_.Equals(other.valueInfo_)) return false;
      if(!function_.Equals(other.function_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= node_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= initializer_.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      hash ^= input_.GetHashCode();
      hash ^= output_.GetHashCode();
      hash ^= valueInfo_.GetHashCode();
      hash ^= function_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      node_.WriteTo(output, _repeated_node_codec);
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      initializer_.WriteTo(output, _repeated_initializer_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(DocString);
      }
      input_.WriteTo(output, _repeated_input_codec);
      output_.WriteTo(output, _repeated_output_codec);
      valueInfo_.WriteTo(output, _repeated_valueInfo_codec);
      function_.WriteTo(output, _repeated_function_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += node_.CalculateSize(_repeated_node_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += initializer_.CalculateSize(_repeated_initializer_codec);
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      size += input_.CalculateSize(_repeated_input_codec);
      size += output_.CalculateSize(_repeated_output_codec);
      size += valueInfo_.CalculateSize(_repeated_valueInfo_codec);
      size += function_.CalculateSize(_repeated_function_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GraphProto other) {
      if (other == null) {
        return;
      }
      node_.Add(other.node_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      initializer_.Add(other.initializer_);
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      input_.Add(other.input_);
      output_.Add(other.output_);
      valueInfo_.Add(other.valueInfo_);
      function_.Add(other.function_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            node_.AddEntriesFrom(input, _repeated_node_codec);
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 42: {
            initializer_.AddEntriesFrom(input, _repeated_initializer_codec);
            break;
          }
          case 82: {
            DocString = input.ReadString();
            break;
          }
          case 90: {
            input_.AddEntriesFrom(input, _repeated_input_codec);
            break;
          }
          case 98: {
            output_.AddEntriesFrom(input, _repeated_output_codec);
            break;
          }
          case 106: {
            valueInfo_.AddEntriesFrom(input, _repeated_valueInfo_codec);
            break;
          }
          case 402: {
            function_.AddEntriesFrom(input, _repeated_function_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class FunctionalModelProto : pb::IMessage<FunctionalModelProto> {
    private static readonly pb::MessageParser<FunctionalModelProto> _parser = new pb::MessageParser<FunctionalModelProto>(() => new FunctionalModelProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FunctionalModelProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusvNext.Pmf1Reflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FunctionalModelProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FunctionalModelProto(FunctionalModelProto other) : this() {
      name_ = other.name_;
      Signature = other.signature_ != null ? other.Signature.Clone() : null;
      types_ = other.types_.Clone();
      functions_ = other.functions_.Clone();
      includes_ = other.includes_.Clone();
      body_ = other.body_.Clone();
      cells_ = other.cells_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FunctionalModelProto Clone() {
      return new FunctionalModelProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 2;
    private global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto signature_;
    /// <summary>
    /// The input/output parameter signature of the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto Signature {
      get { return signature_; }
      set {
        signature_ = value;
      }
    }

    /// <summary>Field number for the "types" field.</summary>
    public const int Types_FieldNumber = 3;
    private static readonly pbc::MapField<string, global::LotusvNext.Types.TypeProto>.Codec _map_types_codec
        = new pbc::MapField<string, global::LotusvNext.Types.TypeProto>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::LotusvNext.Types.TypeProto.Parser), 26);
    private readonly pbc::MapField<string, global::LotusvNext.Types.TypeProto> types_ = new pbc::MapField<string, global::LotusvNext.Types.TypeProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::LotusvNext.Types.TypeProto> Types_ {
      get { return types_; }
    }

    /// <summary>Field number for the "functions" field.</summary>
    public const int FunctionsFieldNumber = 4;
    private static readonly pbc::MapField<string, global::LotusvNext.FunctionDefProto>.Codec _map_functions_codec
        = new pbc::MapField<string, global::LotusvNext.FunctionDefProto>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::LotusvNext.FunctionDefProto.Parser), 34);
    private readonly pbc::MapField<string, global::LotusvNext.FunctionDefProto> functions_ = new pbc::MapField<string, global::LotusvNext.FunctionDefProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::LotusvNext.FunctionDefProto> Functions {
      get { return functions_; }
    }

    /// <summary>Field number for the "includes" field.</summary>
    public const int IncludesFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_includes_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> includes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Included models, identified by a 'namespace.name.version', a relative file path or URI.
    /// This list must be empty if the model kind is 'map'. In 'graph' models, included models may be 
    /// invoked as 'namespace.name'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Includes {
      get { return includes_; }
    }

    /// <summary>Field number for the "body" field.</summary>
    public const int BodyFieldNumber = 6;
    private static readonly pb::FieldCodec<global::LotusvNext.Expressions.Expression> _repeated_body_codec
        = pb::FieldCodec.ForMessage(50, global::LotusvNext.Expressions.Expression.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.Expressions.Expression> body_ = new pbc::RepeatedField<global::LotusvNext.Expressions.Expression>();
    /// <summary>
    /// The body of a model is a list of expressions called the action. The last
    /// expression, which must be an expression list, determines the output value. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.Expressions.Expression> Body {
      get { return body_; }
    }

    /// <summary>Field number for the "cells" field.</summary>
    public const int CellsFieldNumber = 7;
    private static readonly pbc::MapField<string, global::LotusvNext.Library.Types.Cell>.Codec _map_cells_codec
        = new pbc::MapField<string, global::LotusvNext.Library.Types.Cell>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::LotusvNext.Library.Types.Cell.Parser), 58);
    private readonly pbc::MapField<string, global::LotusvNext.Library.Types.Cell> cells_ = new pbc::MapField<string, global::LotusvNext.Library.Types.Cell>();
    /// <summary>
    /// Cells are used to hold trained model parameters and other model-global constants.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::LotusvNext.Library.Types.Cell> Cells {
      get { return cells_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FunctionalModelProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FunctionalModelProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Signature, other.Signature)) return false;
      if (!Types_.Equals(other.Types_)) return false;
      if (!Functions.Equals(other.Functions)) return false;
      if(!includes_.Equals(other.includes_)) return false;
      if(!body_.Equals(other.body_)) return false;
      if (!Cells.Equals(other.Cells)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (signature_ != null) hash ^= Signature.GetHashCode();
      hash ^= Types_.GetHashCode();
      hash ^= Functions.GetHashCode();
      hash ^= includes_.GetHashCode();
      hash ^= body_.GetHashCode();
      hash ^= Cells.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (signature_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Signature);
      }
      types_.WriteTo(output, _map_types_codec);
      functions_.WriteTo(output, _map_functions_codec);
      includes_.WriteTo(output, _repeated_includes_codec);
      body_.WriteTo(output, _repeated_body_codec);
      cells_.WriteTo(output, _map_cells_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (signature_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Signature);
      }
      size += types_.CalculateSize(_map_types_codec);
      size += functions_.CalculateSize(_map_functions_codec);
      size += includes_.CalculateSize(_repeated_includes_codec);
      size += body_.CalculateSize(_repeated_body_codec);
      size += cells_.CalculateSize(_map_cells_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FunctionalModelProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.signature_ != null) {
        if (signature_ == null) {
          signature_ = new global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto();
        }
        Signature.MergeFrom(other.Signature);
      }
      types_.Add(other.types_);
      functions_.Add(other.functions_);
      includes_.Add(other.includes_);
      body_.Add(other.body_);
      cells_.Add(other.cells_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (signature_ == null) {
              signature_ = new global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto();
            }
            input.ReadMessage(signature_);
            break;
          }
          case 26: {
            types_.AddEntriesFrom(input, _map_types_codec);
            break;
          }
          case 34: {
            functions_.AddEntriesFrom(input, _map_functions_codec);
            break;
          }
          case 42: {
            includes_.AddEntriesFrom(input, _repeated_includes_codec);
            break;
          }
          case 50: {
            body_.AddEntriesFrom(input, _repeated_body_codec);
            break;
          }
          case 58: {
            cells_.AddEntriesFrom(input, _map_cells_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Defines a function.
  /// </summary>
  public sealed partial class FunctionDefProto : pb::IMessage<FunctionDefProto> {
    private static readonly pb::MessageParser<FunctionDefProto> _parser = new pb::MessageParser<FunctionDefProto>(() => new FunctionDefProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FunctionDefProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusvNext.Pmf1Reflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FunctionDefProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FunctionDefProto(FunctionDefProto other) : this() {
      name_ = other.name_;
      inputParams_ = other.inputParams_.Clone();
      outputParams_ = other.outputParams_.Clone();
      node_ = other.node_.Clone();
      attr_ = other.attr_.Clone();
      docString_ = other.docString_;
      body_ = other.body_.Clone();
      inputAttributes_ = other.inputAttributes_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FunctionDefProto Clone() {
      return new FunctionDefProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the function.
    /// This field MUST be present for this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "input_params" field.</summary>
    public const int InputParamsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> _repeated_inputParams_codec
        = pb::FieldCodec.ForMessage(18, global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> inputParams_ = new pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto>();
    /// <summary>
    /// The input parameters of the function.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> InputParams {
      get { return inputParams_; }
    }

    /// <summary>Field number for the "output_params" field.</summary>
    public const int OutputParamsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> _repeated_outputParams_codec
        = pb::FieldCodec.ForMessage(26, global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> outputParams_ = new pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto>();
    /// <summary>
    /// The output parameters of the function.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> OutputParams {
      get { return outputParams_; }
    }

    /// <summary>Field number for the "node" field.</summary>
    public const int NodeFieldNumber = 4;
    private static readonly pb::FieldCodec<global::ONNX.NodeProto> _repeated_node_codec
        = pb::FieldCodec.ForMessage(34, global::ONNX.NodeProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.NodeProto> node_ = new pbc::RepeatedField<global::ONNX.NodeProto>();
    /// <summary>
    /// The body of the function.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.NodeProto> Node {
      get { return node_; }
    }

    /// <summary>Field number for the "attr" field.</summary>
    public const int AttrFieldNumber = 5;
    private static readonly pb::FieldCodec<global::ONNX.AttributeProto> _repeated_attr_codec
        = pb::FieldCodec.ForMessage(42, global::ONNX.AttributeProto.Parser);
    private readonly pbc::RepeatedField<global::ONNX.AttributeProto> attr_ = new pbc::RepeatedField<global::ONNX.AttributeProto>();
    /// <summary>
    /// The named attributes of the function.
    /// This makes no sense, placing literals on a function def.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ONNX.AttributeProto> Attr {
      get { return attr_; }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 6;
    private string docString_ = "";
    /// <summary>
    /// An  human-readable documentation for this node in the graph.
    /// This text MAY contain Markdown markup that conforms to http://commonmark.org/. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "body" field.</summary>
    public const int BodyFieldNumber = 101;
    private static readonly pb::FieldCodec<global::LotusvNext.Expressions.Expression> _repeated_body_codec
        = pb::FieldCodec.ForMessage(810, global::LotusvNext.Expressions.Expression.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.Expressions.Expression> body_ = new pbc::RepeatedField<global::LotusvNext.Expressions.Expression>();
    /// <summary>
    /// The body of a model is a list of expressions called the action. The last
    /// expression, which must be an expression list, determines the output value. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.Expressions.Expression> Body {
      get { return body_; }
    }

    /// <summary>Field number for the "input_attributes" field.</summary>
    public const int InputAttributesFieldNumber = 103;
    private static readonly pb::FieldCodec<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> _repeated_inputAttributes_codec
        = pb::FieldCodec.ForMessage(826, global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> inputAttributes_ = new pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto>();
    /// <summary>
    /// The input parameters of the function.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.ParameterDeclProto> InputAttributes {
      get { return inputAttributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FunctionDefProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FunctionDefProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!inputParams_.Equals(other.inputParams_)) return false;
      if(!outputParams_.Equals(other.outputParams_)) return false;
      if(!node_.Equals(other.node_)) return false;
      if(!attr_.Equals(other.attr_)) return false;
      if (DocString != other.DocString) return false;
      if(!body_.Equals(other.body_)) return false;
      if(!inputAttributes_.Equals(other.inputAttributes_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= inputParams_.GetHashCode();
      hash ^= outputParams_.GetHashCode();
      hash ^= node_.GetHashCode();
      hash ^= attr_.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      hash ^= body_.GetHashCode();
      hash ^= inputAttributes_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      inputParams_.WriteTo(output, _repeated_inputParams_codec);
      outputParams_.WriteTo(output, _repeated_outputParams_codec);
      node_.WriteTo(output, _repeated_node_codec);
      attr_.WriteTo(output, _repeated_attr_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(DocString);
      }
      body_.WriteTo(output, _repeated_body_codec);
      inputAttributes_.WriteTo(output, _repeated_inputAttributes_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += inputParams_.CalculateSize(_repeated_inputParams_codec);
      size += outputParams_.CalculateSize(_repeated_outputParams_codec);
      size += node_.CalculateSize(_repeated_node_codec);
      size += attr_.CalculateSize(_repeated_attr_codec);
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      size += body_.CalculateSize(_repeated_body_codec);
      size += inputAttributes_.CalculateSize(_repeated_inputAttributes_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FunctionDefProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      inputParams_.Add(other.inputParams_);
      outputParams_.Add(other.outputParams_);
      node_.Add(other.node_);
      attr_.Add(other.attr_);
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      body_.Add(other.body_);
      inputAttributes_.Add(other.inputAttributes_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            inputParams_.AddEntriesFrom(input, _repeated_inputParams_codec);
            break;
          }
          case 26: {
            outputParams_.AddEntriesFrom(input, _repeated_outputParams_codec);
            break;
          }
          case 34: {
            node_.AddEntriesFrom(input, _repeated_node_codec);
            break;
          }
          case 42: {
            attr_.AddEntriesFrom(input, _repeated_attr_codec);
            break;
          }
          case 50: {
            DocString = input.ReadString();
            break;
          }
          case 810: {
            body_.AddEntriesFrom(input, _repeated_body_codec);
            break;
          }
          case 826: {
            inputAttributes_.AddEntriesFrom(input, _repeated_inputAttributes_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class OperatorDeclProto : pb::IMessage<OperatorDeclProto> {
    private static readonly pb::MessageParser<OperatorDeclProto> _parser = new pb::MessageParser<OperatorDeclProto>(() => new OperatorDeclProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OperatorDeclProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusvNext.Pmf1Reflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorDeclProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorDeclProto(OperatorDeclProto other) : this() {
      name_ = other.name_;
      signature_ = other.signature_.Clone();
      docString_ = other.docString_;
      suffixes_ = other.suffixes_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorDeclProto Clone() {
      return new OperatorDeclProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// This field MUST be present for this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 2;
    private static readonly pb::FieldCodec<global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto> _repeated_signature_codec
        = pb::FieldCodec.ForMessage(18, global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto> signature_ = new pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto>();
    /// <summary>
    /// This field MUST contain at least one SignatureDeclProto.
    /// This field MAY contain multiple SignatureDeclProtos, one 
    /// per type signature supported by this operator.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.Types.TypeProto.Types.SignatureDeclProto> Signature {
      get { return signature_; }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 3;
    private string docString_ = "";
    /// <summary>
    /// An  human-readable documentation for this operator.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "suffixes" field.</summary>
    public const int SuffixesFieldNumber = 101;
    private static readonly pb::FieldCodec<string> _repeated_suffixes_codec
        = pb::FieldCodec.ForString(810);
    private readonly pbc::RepeatedField<string> suffixes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// For each variant, a suffix for the name so that languages that do
    /// not support overloading can make it work.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Suffixes {
      get { return suffixes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OperatorDeclProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OperatorDeclProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!signature_.Equals(other.signature_)) return false;
      if (DocString != other.DocString) return false;
      if(!suffixes_.Equals(other.suffixes_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= signature_.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      hash ^= suffixes_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      signature_.WriteTo(output, _repeated_signature_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DocString);
      }
      suffixes_.WriteTo(output, _repeated_suffixes_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += signature_.CalculateSize(_repeated_signature_codec);
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      size += suffixes_.CalculateSize(_repeated_suffixes_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OperatorDeclProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      signature_.Add(other.signature_);
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      suffixes_.Add(other.suffixes_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            signature_.AddEntriesFrom(input, _repeated_signature_codec);
            break;
          }
          case 26: {
            DocString = input.ReadString();
            break;
          }
          case 810: {
            suffixes_.AddEntriesFrom(input, _repeated_suffixes_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class Library : pb::IMessage<Library> {
    private static readonly pb::MessageParser<Library> _parser = new pb::MessageParser<Library>(() => new Library());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Library> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusvNext.Pmf1Reflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Library() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Library(Library other) : this() {
      irVersion_ = other.irVersion_;
      producerVersion_ = other.producerVersion_;
      producerTag_ = other.producerTag_;
      modelVersion_ = other.modelVersion_;
      modelAuthor_ = other.modelAuthor_;
      modelLicense_ = other.modelLicense_;
      name_ = other.name_;
      domain_ = other.domain_;
      docString_ = other.docString_;
      operator_ = other.operator_.Clone();
      function_ = other.function_.Clone();
      importedLibraries_ = other.importedLibraries_.Clone();
      metadata_ = other.metadata_.Clone();
      types_ = other.types_.Clone();
      excluded_ = other.excluded_.Clone();
      cells_ = other.cells_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Library Clone() {
      return new Library(this);
    }

    /// <summary>Field number for the "ir_version" field.</summary>
    public const int IrVersionFieldNumber = 1;
    private long irVersion_;
    /// <summary>
    /// The version of the IR this graph targets. See Version enum below.
    /// This field MUST be present this version of the IR.  
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IrVersion {
      get { return irVersion_; }
      set {
        irVersion_ = value;
      }
    }

    /// <summary>Field number for the "producer_version" field.</summary>
    public const int ProducerVersionFieldNumber = 2;
    private long producerVersion_;
    /// <summary>
    /// The  version of the framework runtime that generates this graph.
    /// This producer_version has the same format as ir_version. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ProducerVersion {
      get { return producerVersion_; }
      set {
        producerVersion_ = value;
      }
    }

    /// <summary>Field number for the "producer_tag" field.</summary>
    public const int ProducerTagFieldNumber = 3;
    private string producerTag_ = "";
    /// <summary>
    /// The  name of the framework used to generate this graph in the form
    /// "framework_name[-tag]". Tag is  and provides additional
    /// information such as `alpha` or `beta` or `rc3`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProducerTag {
      get { return producerTag_; }
      set {
        producerTag_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_version" field.</summary>
    public const int ModelVersionFieldNumber = 4;
    private long modelVersion_;
    /// <summary>
    /// An  version identifier used to track evolution of this library.
    /// This model_version has the same format as ir_version. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ModelVersion {
      get { return modelVersion_; }
      set {
        modelVersion_ = value;
      }
    }

    /// <summary>Field number for the "model_author" field.</summary>
    public const int ModelAuthorFieldNumber = 5;
    private string modelAuthor_ = "";
    /// <summary>
    /// The  name of the author who created the library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelAuthor {
      get { return modelAuthor_; }
      set {
        modelAuthor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_license" field.</summary>
    public const int ModelLicenseFieldNumber = 6;
    private string modelLicense_ = "";
    /// <summary>
    ///  licensing information concerning use or origination of the library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelLicense {
      get { return modelLicense_; }
      set {
        modelLicense_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 7;
    private string name_ = "";
    /// <summary>
    /// The name of the library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "domain" field.</summary>
    public const int DomainFieldNumber = 8;
    private string domain_ = "";
    /// <summary>
    /// Domain of the graph.
    /// We use reverse domain names as name space indicators. For example:
    /// `com.facebook.fair` or `com.microsoft.cognitiveservices`
    ///
    /// Together with `name` and `model_version`, this forms the unique identity of
    /// the library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Domain {
      get { return domain_; }
      set {
        domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 9;
    private string docString_ = "";
    /// <summary>
    /// An  human-readable documentation for this graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "operator" field.</summary>
    public const int OperatorFieldNumber = 10;
    private static readonly pb::FieldCodec<global::LotusvNext.OperatorDeclProto> _repeated_operator_codec
        = pb::FieldCodec.ForMessage(82, global::LotusvNext.OperatorDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.OperatorDeclProto> operator_ = new pbc::RepeatedField<global::LotusvNext.OperatorDeclProto>();
    /// <summary>
    /// The operators declared by this library. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.OperatorDeclProto> Operator {
      get { return operator_; }
    }

    /// <summary>Field number for the "function" field.</summary>
    public const int FunctionFieldNumber = 11;
    private static readonly pb::FieldCodec<global::LotusvNext.FunctionDefProto> _repeated_function_codec
        = pb::FieldCodec.ForMessage(90, global::LotusvNext.FunctionDefProto.Parser);
    private readonly pbc::RepeatedField<global::LotusvNext.FunctionDefProto> function_ = new pbc::RepeatedField<global::LotusvNext.FunctionDefProto>();
    /// <summary>
    /// The function definitions of the library. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusvNext.FunctionDefProto> Function {
      get { return function_; }
    }

    /// <summary>Field number for the "imported_libraries" field.</summary>
    public const int ImportedLibrariesFieldNumber = 12;
    private static readonly pb::FieldCodec<string> _repeated_importedLibraries_codec
        = pb::FieldCodec.ForString(98);
    private readonly pbc::RepeatedField<string> importedLibraries_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Imported libraries are referenced as a collection of strings in the form of absolute
    /// URIs or relative paths. Where such relative paths are rooted is defined by tools and
    /// runtime implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ImportedLibraries {
      get { return importedLibraries_; }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 100;
    private static readonly pbc::MapField<string, string>.Codec _map_metadata_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 802);
    private readonly pbc::MapField<string, string> metadata_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional metadata
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Metadata {
      get { return metadata_; }
    }

    /// <summary>Field number for the "types" field.</summary>
    public const int Types_FieldNumber = 101;
    private static readonly pbc::MapField<string, global::LotusvNext.Types.TypeProto>.Codec _map_types_codec
        = new pbc::MapField<string, global::LotusvNext.Types.TypeProto>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::LotusvNext.Types.TypeProto.Parser), 810);
    private readonly pbc::MapField<string, global::LotusvNext.Types.TypeProto> types_ = new pbc::MapField<string, global::LotusvNext.Types.TypeProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::LotusvNext.Types.TypeProto> Types_ {
      get { return types_; }
    }

    /// <summary>Field number for the "excluded" field.</summary>
    public const int ExcludedFieldNumber = 102;
    private static readonly pb::FieldCodec<string> _repeated_excluded_codec
        = pb::FieldCodec.ForString(818);
    private readonly pbc::RepeatedField<string> excluded_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// The list of excluded languages features, typically names of operators.
    /// TODO: Define the language features as an enum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Excluded {
      get { return excluded_; }
    }

    /// <summary>Field number for the "cells" field.</summary>
    public const int CellsFieldNumber = 103;
    private static readonly pbc::MapField<string, global::LotusvNext.Library.Types.Cell>.Codec _map_cells_codec
        = new pbc::MapField<string, global::LotusvNext.Library.Types.Cell>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::LotusvNext.Library.Types.Cell.Parser), 826);
    private readonly pbc::MapField<string, global::LotusvNext.Library.Types.Cell> cells_ = new pbc::MapField<string, global::LotusvNext.Library.Types.Cell>();
    /// <summary>
    /// In profiles, cells are used to hold constants to be shared by models.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::LotusvNext.Library.Types.Cell> Cells {
      get { return cells_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Library);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Library other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IrVersion != other.IrVersion) return false;
      if (ProducerVersion != other.ProducerVersion) return false;
      if (ProducerTag != other.ProducerTag) return false;
      if (ModelVersion != other.ModelVersion) return false;
      if (ModelAuthor != other.ModelAuthor) return false;
      if (ModelLicense != other.ModelLicense) return false;
      if (Name != other.Name) return false;
      if (Domain != other.Domain) return false;
      if (DocString != other.DocString) return false;
      if(!operator_.Equals(other.operator_)) return false;
      if(!function_.Equals(other.function_)) return false;
      if(!importedLibraries_.Equals(other.importedLibraries_)) return false;
      if (!Metadata.Equals(other.Metadata)) return false;
      if (!Types_.Equals(other.Types_)) return false;
      if(!excluded_.Equals(other.excluded_)) return false;
      if (!Cells.Equals(other.Cells)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (IrVersion != 0L) hash ^= IrVersion.GetHashCode();
      if (ProducerVersion != 0L) hash ^= ProducerVersion.GetHashCode();
      if (ProducerTag.Length != 0) hash ^= ProducerTag.GetHashCode();
      if (ModelVersion != 0L) hash ^= ModelVersion.GetHashCode();
      if (ModelAuthor.Length != 0) hash ^= ModelAuthor.GetHashCode();
      if (ModelLicense.Length != 0) hash ^= ModelLicense.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Domain.Length != 0) hash ^= Domain.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      hash ^= operator_.GetHashCode();
      hash ^= function_.GetHashCode();
      hash ^= importedLibraries_.GetHashCode();
      hash ^= Metadata.GetHashCode();
      hash ^= Types_.GetHashCode();
      hash ^= excluded_.GetHashCode();
      hash ^= Cells.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (IrVersion != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(IrVersion);
      }
      if (ProducerVersion != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(ProducerVersion);
      }
      if (ProducerTag.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ProducerTag);
      }
      if (ModelVersion != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(ModelVersion);
      }
      if (ModelAuthor.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(ModelAuthor);
      }
      if (ModelLicense.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(ModelLicense);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(Name);
      }
      if (Domain.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Domain);
      }
      if (DocString.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(DocString);
      }
      operator_.WriteTo(output, _repeated_operator_codec);
      function_.WriteTo(output, _repeated_function_codec);
      importedLibraries_.WriteTo(output, _repeated_importedLibraries_codec);
      metadata_.WriteTo(output, _map_metadata_codec);
      types_.WriteTo(output, _map_types_codec);
      excluded_.WriteTo(output, _repeated_excluded_codec);
      cells_.WriteTo(output, _map_cells_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (IrVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IrVersion);
      }
      if (ProducerVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ProducerVersion);
      }
      if (ProducerTag.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProducerTag);
      }
      if (ModelVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ModelVersion);
      }
      if (ModelAuthor.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelAuthor);
      }
      if (ModelLicense.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelLicense);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Domain.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      size += operator_.CalculateSize(_repeated_operator_codec);
      size += function_.CalculateSize(_repeated_function_codec);
      size += importedLibraries_.CalculateSize(_repeated_importedLibraries_codec);
      size += metadata_.CalculateSize(_map_metadata_codec);
      size += types_.CalculateSize(_map_types_codec);
      size += excluded_.CalculateSize(_repeated_excluded_codec);
      size += cells_.CalculateSize(_map_cells_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Library other) {
      if (other == null) {
        return;
      }
      if (other.IrVersion != 0L) {
        IrVersion = other.IrVersion;
      }
      if (other.ProducerVersion != 0L) {
        ProducerVersion = other.ProducerVersion;
      }
      if (other.ProducerTag.Length != 0) {
        ProducerTag = other.ProducerTag;
      }
      if (other.ModelVersion != 0L) {
        ModelVersion = other.ModelVersion;
      }
      if (other.ModelAuthor.Length != 0) {
        ModelAuthor = other.ModelAuthor;
      }
      if (other.ModelLicense.Length != 0) {
        ModelLicense = other.ModelLicense;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Domain.Length != 0) {
        Domain = other.Domain;
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      operator_.Add(other.operator_);
      function_.Add(other.function_);
      importedLibraries_.Add(other.importedLibraries_);
      metadata_.Add(other.metadata_);
      types_.Add(other.types_);
      excluded_.Add(other.excluded_);
      cells_.Add(other.cells_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            IrVersion = input.ReadInt64();
            break;
          }
          case 16: {
            ProducerVersion = input.ReadInt64();
            break;
          }
          case 26: {
            ProducerTag = input.ReadString();
            break;
          }
          case 32: {
            ModelVersion = input.ReadInt64();
            break;
          }
          case 42: {
            ModelAuthor = input.ReadString();
            break;
          }
          case 50: {
            ModelLicense = input.ReadString();
            break;
          }
          case 58: {
            Name = input.ReadString();
            break;
          }
          case 66: {
            Domain = input.ReadString();
            break;
          }
          case 74: {
            DocString = input.ReadString();
            break;
          }
          case 82: {
            operator_.AddEntriesFrom(input, _repeated_operator_codec);
            break;
          }
          case 90: {
            function_.AddEntriesFrom(input, _repeated_function_codec);
            break;
          }
          case 98: {
            importedLibraries_.AddEntriesFrom(input, _repeated_importedLibraries_codec);
            break;
          }
          case 802: {
            metadata_.AddEntriesFrom(input, _map_metadata_codec);
            break;
          }
          case 810: {
            types_.AddEntriesFrom(input, _map_types_codec);
            break;
          }
          case 818: {
            excluded_.AddEntriesFrom(input, _repeated_excluded_codec);
            break;
          }
          case 826: {
            cells_.AddEntriesFrom(input, _map_cells_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Library message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Cell : pb::IMessage<Cell> {
        private static readonly pb::MessageParser<Cell> _parser = new pb::MessageParser<Cell>(() => new Cell());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Cell> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusvNext.Library.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Cell() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Cell(Cell other) : this() {
          source_ = other.source_;
          Type = other.type_ != null ? other.Type.Clone() : null;
          Init = other.init_ != null ? other.Init.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Cell Clone() {
          return new Cell(this);
        }

        /// <summary>Field number for the "source" field.</summary>
        public const int SourceFieldNumber = 1;
        private string source_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Source {
          get { return source_; }
          set {
            source_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 2;
        private global::LotusvNext.Types.TypeProto type_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusvNext.Types.TypeProto Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "init" field.</summary>
        public const int InitFieldNumber = 3;
        private global::LotusvNext.Expressions.ValueProto init_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusvNext.Expressions.ValueProto Init {
          get { return init_; }
          set {
            init_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Cell);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Cell other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Source != other.Source) return false;
          if (!object.Equals(Type, other.Type)) return false;
          if (!object.Equals(Init, other.Init)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Source.Length != 0) hash ^= Source.GetHashCode();
          if (type_ != null) hash ^= Type.GetHashCode();
          if (init_ != null) hash ^= Init.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Source.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Source);
          }
          if (type_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Type);
          }
          if (init_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(Init);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Source.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Source);
          }
          if (type_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Type);
          }
          if (init_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Init);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Cell other) {
          if (other == null) {
            return;
          }
          if (other.Source.Length != 0) {
            Source = other.Source;
          }
          if (other.type_ != null) {
            if (type_ == null) {
              type_ = new global::LotusvNext.Types.TypeProto();
            }
            Type.MergeFrom(other.Type);
          }
          if (other.init_ != null) {
            if (init_ == null) {
              init_ = new global::LotusvNext.Expressions.ValueProto();
            }
            Init.MergeFrom(other.Init);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Source = input.ReadString();
                break;
              }
              case 18: {
                if (type_ == null) {
                  type_ = new global::LotusvNext.Types.TypeProto();
                }
                input.ReadMessage(type_);
                break;
              }
              case 26: {
                if (init_ == null) {
                  init_ = new global::LotusvNext.Expressions.ValueProto();
                }
                input.ReadMessage(init_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// OperatorSets are uniquely identified by a (domain, opset_version) pair.
  /// </summary>
  public sealed partial class OperatorSetIdProto : pb::IMessage<OperatorSetIdProto> {
    private static readonly pb::MessageParser<OperatorSetIdProto> _parser = new pb::MessageParser<OperatorSetIdProto>(() => new OperatorSetIdProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OperatorSetIdProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusvNext.Pmf1Reflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorSetIdProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorSetIdProto(OperatorSetIdProto other) : this() {
      domain_ = other.domain_;
      version_ = other.version_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorSetIdProto Clone() {
      return new OperatorSetIdProto(this);
    }

    /// <summary>Field number for the "domain" field.</summary>
    public const int DomainFieldNumber = 1;
    private string domain_ = "";
    /// <summary>
    /// The domain of the operator set being identified.
    /// The empty string ("") or absence of this field implies the operator
    /// set that is defined as part of the ONNX specification.
    /// This field MUST be present in this version of the IR when referring to any other operator set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Domain {
      get { return domain_; }
      set {
        domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 2;
    private long version_;
    /// <summary>
    /// The version of the operator set being identified.
    /// This field MUST be present in this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OperatorSetIdProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OperatorSetIdProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Domain != other.Domain) return false;
      if (Version != other.Version) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Domain.Length != 0) hash ^= Domain.GetHashCode();
      if (Version != 0L) hash ^= Version.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Domain.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Domain);
      }
      if (Version != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Version);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Domain.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
      }
      if (Version != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Version);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OperatorSetIdProto other) {
      if (other == null) {
        return;
      }
      if (other.Domain.Length != 0) {
        Domain = other.Domain;
      }
      if (other.Version != 0L) {
        Version = other.Version;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Domain = input.ReadString();
            break;
          }
          case 16: {
            Version = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
